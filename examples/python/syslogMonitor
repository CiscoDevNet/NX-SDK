#!/usr/bin/python 

###############################################################
# NX-SDK Remote Python Application to detect duplicate hosts
# in the network using NxAdjMgr. 
#
# Refer to switch_details.json which has the details of the switch nodes
# this remote application is connecting to. switch_details.json can be
# updated on the fly (new switches can be added and also existing
# switches can be deleted too) and this application gracefully
# handle the changes.
###############################################################
import os, os.path
import signal
import time
import threading
import sys
import json
import datetime

## To gain access into NX-OS infra.
import nx_sdk_py

### Global variables
switchInfo_dict = {}

### Read-Write Lock
class rwLock:
    def __init__(self, max_readers):
        self._read_ready = threading.Condition(threading.Lock())
        self._readers = 0

    def rdLock(self):
        self._read_ready.acquire()
        try:
            self._readers += 1
        finally:
            self._read_ready.release()

    def rdUnlock(self):
        self._read_ready.acquire()
        try:
            self._readers -= 1
            if not self._readers:
                self._read_ready.notifyAll()
        finally:
            self._read_ready.release()

    def wrLock(self):
        self._read_ready.acquire()
        while self._readers > 0:
            self._read_ready.wait()

    def wrUnlock(self):
        self._read_ready.release()
        
switchInfo_lock = rwLock(32)

def getTracer(switch_ip):
    global switchInfo_dict
    if switch_ip in switchInfo_dict:
       if "tracer" in switchInfo_dict[switch_ip]:
          return switchInfo_dict[switch_ip]["tracer"]
    return 0  

class pySdkHandler(nx_sdk_py.NxSdkHandler):
      global switchInfo_dict
      #def __init__(self, switch_ip):
      #    self.switch_ip = "switch_ip"
      def setSwitchIp(self, switch_ip):
          self.switch_ip = switch_ip          
      def postRemoteConnDownCb(self, nxsdk):
          switchInfo_lock.rdLock()
          trace = getTracer(self.switch_ip)
          if trace:
             trace.event("IP %s connection down, all objs obsolete" % nxsdk.getRemoteIp())
          if self.switch_ip in switchInfo_dict:
             switchInfo_dict[self.switch_ip]["reason"] = "Connection down"
          switchInfo_lock.rdUnlock()
          nxsdk.stopEventLoop()

class pyTraceHandler(nx_sdk_py.NxTraceHandler):
      global switchInfo_dict, switchInfo_dict_lock
      #def __init__(self, switch_ip):
      #    self.switch_ip = switch_ip
      def setSwitchIp(self, switch_ip):
          self.switch_ip = switch_ip

      ### Syslog Section    
      def postSyslogDownloadDoneCb(self):
          print "Recevied syslog download done\n"
      def postSyslogCb(self, nxsyslog):
          switchInfo_lock.rdLock()
          if self.switch_ip in switchInfo_dict:
             switchInfo_dict[self.switch_ip]["event_cnt"] += 1
          print "[%s] Rcvd Syslog event Id : %u\nNodeName: %s\nTimeStamp: %s %s\nSeverity: %u\nMessageName: %s\nCategory: %s\nText: %s\n" % \
                (self.switch_ip, nxsyslog.getId(), nxsyslog.getNodeName(), nxsyslog.getTimeStamp(), nxsyslog.getTimeZone(), nxsyslog.getSeverity(), nxsyslog.getMessageName(), \
                 nxsyslog.getCategory(), nxsyslog.getText())
          switchInfo_lock.rdUnlock()   
      # end of syslog section    

def sdkThread(addr, port, switchInfo):
    global switchInfo_dict_lock
    try:
       switchInfo_lock.rdLock() 
       switchInfo["sdk_inst"] = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), \
                                                  sys.argv, True, addr, port)
       if not switchInfo["sdk_inst"]:
          switchInfo_lock.rdUnlock()
          return

       ### Get Tracer object
       switchInfo["tracer"] = switchInfo["sdk_inst"].getTracer()
       if not switchInfo["tracer"]:
          switchInfo["reason"] = "Could not get tracer object" 
          nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
          switchInfo_lock.rdUnlock()
          return
       switchInfo["reason"] = "Connected"
       switchInfo_dict[addr]["event_cnt"] = 0

       ### Set SDk handler to handle remote connection up/down
       mySdkHandler = pySdkHandler()
       mySdkHandler.setSwitchIp(addr)
       switchInfo["sdk_inst"].setSdkHandler(mySdkHandler)

       myTraceHandler = pyTraceHandler()
       myTraceHandler.setSwitchIp(addr)

       ### Syslog Section
       switchInfo["tracer"].setTraceHandler(myTraceHandler)
       switchInfo["tracer"].watchSyslog(True)
       ### End of syslog

       switchInfo_lock.rdUnlock()

       ###
       # startEventLoop will block the thread until we break out
       # of it by calling stopEventLoop. This is required to
       # receive any NX-OS specific events. Without this, none of
       # the NXSDK functionalities will work.
       ###
       switchInfo["sdk_inst"].startEventLoop()

       switchInfo_lock.rdLock()
       switchInfo["tracer"].event("Deleting SDK inst")

       ### [Required] Needed for graceful exit.
       nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
       switchInfo["sdk_inst"] = 0
       switchInfo["tracer"]   = 0
       switchInfo_lock.rdUnlock()
    except nx_sdk_py.NxException as e:
           switchInfo["reason"]   = e.what()
           if switchInfo["tracer"]:
              switchInfo["tracer"].event("Exception: Module: %s, API: %s, Severity: %s, ErrCode %d(%s)" % (e.getErrModule(), e.getErrApi(), nx_sdk_py.NxTrace.getPrioStr(e.getErrSeverity()), e.getErrCode(), e.what()))    
           if switchInfo["sdk_inst"]:
              nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
           switchInfo["sdk_inst"] = 0
           switchInfo["tracer"]   = 0
           switchInfo_lock.rdUnlock()


###
# To load switch info into a dictionary from
# switch_details.json file. 
###
def loadSwitchInfo():
    global switchInfo_dict

    switchFileInfo = {}
    app_name = os.path.basename(__file__)

    if switchInfo_dict:
        print "\n\nTime: %s\n" % datetime.datetime.now()
        print "{0:15} | {1:25} | {2:10} | {3:10} | {4:10}".format("Switch", "Addr:Port", "SDK Inst", "Events Cnt", "Status")
        print "----------------------------------------------------------------------------------"
        switchInfo_lock.rdLock()
        for switch in switchInfo_dict:
            sdk_inst     = "No"
            is_connected = "-" 
            if switchInfo_dict[switch]["sdk_inst"]:
               sdk_inst = "Yes"
               if switchInfo_dict[switch]["sdk_inst"].getRemoteConnStatus() == nx_sdk_py.UP:
                  is_connected = "Yes"
            print "{0:15} | {1:25} | {2:10} | {3:10} | {4:10}\n".format(switchInfo_dict[switch]["name"], \
                    switch + ":" + str(switchInfo_dict[switch]["port"]),\
                  sdk_inst, switchInfo_dict[switch]["event_cnt"], switchInfo_dict[switch]["reason"])
        switchInfo_lock.rdUnlock()

    with open("switch_details.json", 'r') as switch_json_file:
         switchFileInfo = json.loads(switch_json_file.read())["switchInfo"]

    ### Add new switches to the list     
    got_wr_lock = False
    for switch_det in switchFileInfo:     
        addr = str(switch_det["addr"])
        switch_det_port = 0

        ### check if app is part of the switchInfo
        found_switch = False
        for port_apps in switch_det["port-apps"]:
            if app_name == port_apps["app"]:
               switch_det_port = port_apps["port"]
               found_switch = True
               break

        if not found_switch:
           continue

        switchInfo_lock.rdLock()
        if addr not in switchInfo_dict:
           switchInfo_dict[addr] = {}
           switchInfo_lock.rdUnlock()
           switchInfo_lock.wrLock()
           got_wr_lock = True
        elif "port" in switchInfo_dict[addr] and switchInfo_dict[addr]["port"] != switch_det_port:
           print "Err: Wrong port given: " + str(switch_det_port) + " as Switch " + addr + \
                 " already attached to port " + str(switchInfo_dict[addr]["port"]) + "\n"  
           switchInfo_lock.rdUnlock()
           continue
        switchInfo_dict[addr]["port"]   = switch_det_port
        switchInfo_dict[addr]["name"]   = switch_det["name"]
        switchInfo_dict[addr]["done"]   = True
        if "reason" not in switchInfo_dict[addr]:
           switchInfo_dict[addr]["reason"] = ""
        if "event_cnt" not in switchInfo_dict[addr]:   
           switchInfo_dict[addr]["event_cnt"] = 0
        if "sdk_inst" not in switchInfo_dict[addr]:
           switchInfo_dict[addr]["sdk_inst"] = 0

        if got_wr_lock:
           switchInfo_lock.wrUnlock()
           switchInfo_lock.rdLock()

        ### SDK inst does not exist hence try to init with NX-SDK.   
        if not switchInfo_dict[addr]["sdk_inst"]:
           sdk_thread = threading.Thread(target=sdkThread, \
                         args=(str(addr), switch_det_port, \
                         switchInfo_dict[addr]))
           sdk_thread.start()           
        switchInfo_lock.rdUnlock()

    ### Check for deleted switches and remove them
    delete_switch_list = []
    for switch_addr in switchInfo_dict:
        switch_det = switchInfo_dict[switch_addr]
        if "done" in switch_det:
           switch_det.pop("done")
        else:
           ### Switch has been deleted remove it.
           delete_switch_list.append(switch_addr)
    got_lock = False
    if delete_switch_list:
       got_lock = True
       switchInfo_lock.wrLock()           
    for switch_addr in delete_switch_list:
        if switch_addr in switchInfo_dict:
           if switchInfo_dict[switch_addr]["sdk_inst"]: 
              switchInfo_dict[switch_addr]["sdk_inst"].stopEventLoop()
              #while switchInfo_dict[switch_addr]["sdk_inst"]:
              time.sleep(2)
           switchInfo_dict.pop(switch_addr)       
           print "Deleted Switch " + switch_addr + " from the List"
    if got_lock:
       switchInfo_lock.wrUnlock()           

while True:
    loadSwitchInfo()
    time.sleep(7)
