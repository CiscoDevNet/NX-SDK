#!/usr/bin/python 

###############################################################
# NX-SDK Remote Python Application to detect duplicate hosts
# in the network using NxAdjMgr. 
#
# Refer to switch_details.json which has the details of the switch nodes
# this remote application is connecting to. switch_details.json can be
# updated on the fly (new switches can be added and also existing
# switches can be deleted too) and this application gracefully
# handle the changes.
###############################################################
import os, os.path
import signal
import time
import threading
import sys
import json
import datetime

## To gain access into NX-OS infra.
import nx_sdk_py

### Global variables
switchInfo_dict = {}

dupHost_dict    = {}
switch_pfx_dict = {}
adj_dict        = {}

### Read-Write Lock
class rwLock:
    def __init__(self, max_readers):
        self._read_ready = threading.Condition(threading.Lock())
        self._readers = 0

    def rdLock(self):
        self._read_ready.acquire()
        try:
            self._readers += 1
        finally:
            self._read_ready.release()

    def rdUnlock(self):
        self._read_ready.acquire()
        try:
            self._readers -= 1
            if not self._readers:
                self._read_ready.notifyAll()
        finally:
            self._read_ready.release()

    def wrLock(self):
        self._read_ready.acquire()
        while self._readers > 0:
            self._read_ready.wait()

    def wrUnlock(self):
        self._read_ready.release()
        
switchInfo_lock = rwLock(32)
adj_dict_lock   = rwLock(32)

def getTracer(switch_ip):
    global switchInfo_dict
    if switch_ip in switchInfo_dict:
       if "tracer" in switchInfo_dict[switch_ip]:
          return switchInfo_dict[switch_ip]["tracer"]
    return 0  

class pySdkHandler(nx_sdk_py.NxSdkHandler):
      global switchInfo_dict
      #def __init__(self, switch_ip):
      #    self.switch_ip = "switch_ip"
      def setSwitchIp(self, switch_ip):
          self.switch_ip = switch_ip          
      def postRemoteConnDownCb(self, nxsdk):
          switchInfo_lock.rdLock()
          trace = getTracer(self.switch_ip)
          if trace:
             trace.event("IP %s connection down, all objs obsolete" % nxsdk.getRemoteIp())
          if self.switch_ip in switchInfo_dict:
             switchInfo_dict[self.switch_ip]["reason"] = "Connection down"
          switchInfo_lock.rdUnlock()
          nxsdk.stopEventLoop()

###
# To delete an adj from the dicts:
# Caller should take the lock.
###
def nx_delete_adj(trace, switch_ip, intf, ip_addr):
    global dupHost_dict, adj_dict, switch_pfx_dict

    if intf not in adj_dict:
       return
    if ip_addr not in adj_dict[intf]:
       return

    adj_dict_info = adj_dict[intf][ip_addr]
    dup_key       = intf + ":" + ip_addr

    if switch_ip in adj_dict_info["switch"]:
       adj_dict_info["switch"].pop(switch_ip)

    if switch_ip in switch_pfx_dict:
       if dup_key in switch_pfx_dict[switch_ip]:
          switch_pfx_dict[switch_ip].pop(dup_key)
       if not switch_pfx_dict[switch_ip]:
          switch_pfx_dict.pop(switch_ip)

    if len(adj_dict_info["switch"]) <= 1:
       ##Dup host detected
       if dup_key in dupHost_dict:
          dupHost_dict.pop(dup_key)
          if len(adj_dict_info["switch"]) == 1:
             print "[" + adj_dict_info["vrf"] + "] Host " + ip_addr + " in intf " + intf + " moved from " + \
                   switch_ip + " to " + adj_dict_info["switch"].keys()[0] + "\n"
    if not adj_dict_info["switch"]:
       adj_dict[intf].pop(ip_addr)
    if not adj_dict[intf]:
       adj_dict.pop(intf)

###
# To delete all adjs from the dicts from the specified switch.
# Caller should take the lock.
###
def nx_delete_all_adjs(trace, switch_ip):
    global switch_pfx_dict, adj_dict_lock

    adj_dict_lock.wrLock()
    if switch_ip in switch_pfx_dict:
        keys_list = list(switch_pfx_dict[switch_ip].keys())
        for key in keys_list:
            (intf, ip_addr) = key.split(":")
            nx_delete_adj(trace, switch_ip, intf, ip_addr)
    adj_dict_lock.wrUnlock()

class pyAdjHandler(nx_sdk_py.NxAdjMgrHandler):
      global switchInfo_dict, dupHost_dict, adj_dict, switch_pfx_dict, switchInfo_dict_lock, adj_dict_lock
      #def __init__(self, switch_ip):
      #    self.switch_ip = switch_ip
      def setSwitchIp(self, switch_ip):
          self.switch_ip = switch_ip
      def postAdjCb(self, nxadj):
          switchInfo_lock.rdLock()
          if self.switch_ip in switchInfo_dict:
             switchInfo_dict[self.switch_ip]["event_cnt"] += 1
          trace = getTracer(self.switch_ip)
          status = "Add"
          if nxadj.getEvent() == nx_sdk_py.DELETE:
             status = "Delete"
          if trace:   
             trace.event("[%s] Rcvd AM event %s %s %s" % (status, nxadj.getIpAddr(), nxadj.getMacAddr(), nxadj.getIntfName()))

          dup_key = nxadj.getIntfName() + ":" + nxadj.getIpAddr()

          adj_dict_lock.wrLock()   
          if nxadj.getIntfName() not in adj_dict:             
             if status == "Delete":
                adj_dict_lock.wrUnlock() 
                return 
             adj_dict[nxadj.getIntfName()] = {}
          if nxadj.getIpAddr() not in adj_dict[nxadj.getIntfName()]:
             if status == "Delete":
                adj_dict_lock.wrUnlock()
                return
             adj_dict[nxadj.getIntfName()][nxadj.getIpAddr()] = {}
             if self.switch_ip not in switch_pfx_dict:
                switch_pfx_dict[self.switch_ip] =  {}
             switch_pfx_dict[self.switch_ip][dup_key] = True     
          
          adj_dict_info = adj_dict[nxadj.getIntfName()][nxadj.getIpAddr()]
          if status == "Add":
             adj_dict_info["intf"]   = nxadj.getIntfName()
             adj_dict_info["vrf"]    = nxadj.getVrf()
             adj_dict_info["addr"]   = nxadj.getIpAddr()
             adj_dict_info["phy"]    = nxadj.getPhyIntfName()
             adj_dict_info["mac"]    = nxadj.getMacAddr()
             if "switch" not in adj_dict_info:
                adj_dict_info["switch"] = {}
             adj_dict_info["switch"][self.switch_ip] = True  
             if len(adj_dict_info["switch"]) >= 2:
                ##Dup host detected
                dupHost_dict[dup_key] = time.time()             
          else:  
              nx_delete_adj(trace, self.switch_ip, nxadj.getIntfName(), nxadj.getIpAddr())
          adj_dict_lock.wrUnlock()
          switchInfo_lock.rdUnlock()   
      def postAdjIPv4DownloadDone(self, intfName, ipaddr):
          switchInfo_lock.rdLock()
          if self.switch_ip in switchInfo_dict:
             switchInfo_dict[self.switch_ip]["event_cnt"] += 1
          trace = getTracer(self.switch_ip)
          if trace:
             trace.event("Rcvd IPv4 AdjMfr download done")
          switchInfo_lock.rdUnlock()


def sdkThread(addr, port, switchInfo):
    global switchInfo_dict_lock
    try:
       switchInfo_lock.rdLock() 
       switchInfo["sdk_inst"] = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), \
                                                  sys.argv, True, addr, port)
       if not switchInfo["sdk_inst"]:
          switchInfo_lock.rdUnlock()
          return

       ### Get Tracer object
       switchInfo["tracer"] = switchInfo["sdk_inst"].getTracer()
       if not switchInfo["tracer"]:
          switchInfo["reason"] = "Could not get tracer object" 
          nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
          switchInfo_lock.rdUnlock()
          return
       switchInfo["reason"] = "Connected"
       switchInfo_dict[addr]["event_cnt"] = 0

       ### Set SDk handler to handle remote connection up/down
       mySdkHandler = pySdkHandler()
       mySdkHandler.setSwitchIp(addr)
       switchInfo["sdk_inst"].setSdkHandler(mySdkHandler)

       adjMgr = switchInfo["sdk_inst"].getAdjMgr()
       if adjMgr:
          myAdjHandler = pyAdjHandler()
          myAdjHandler.setSwitchIp(addr)
          adjMgr.setAdjMgrHandler(myAdjHandler)
          adjMgr.watchAllAdjs()

       switchInfo_lock.rdUnlock()

       ###
       # startEventLoop will block the thread until we break out
       # of it by calling stopEventLoop. This is required to
       # receive any NX-OS specific events. Without this, none of
       # the NXSDK functionalities will work.
       ###
       switchInfo["sdk_inst"].startEventLoop()

       switchInfo_lock.rdLock()
       switchInfo["tracer"].event("Deleting SDK inst")
       ### Delete all the learnt adjs from this switch as the connection is terminated
       nx_delete_all_adjs(switchInfo["tracer"], addr)

       ### [Required] Needed for graceful exit.
       nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
       switchInfo["sdk_inst"] = 0
       switchInfo["tracer"]   = 0
       switchInfo_lock.rdUnlock()
    except nx_sdk_py.NxException as e:
           switchInfo["reason"]   = e.what()
           if switchInfo["tracer"]:
              switchInfo["tracer"].event("Exception: Module: %s, API: %s, Severity: %s, ErrCode %d(%s)" % (e.getErrModule(), e.getErrApi(), nx_sdk_py.NxTrace.getPrioStr(e.getErrSeverity()), e.getErrCode(), e.what()))    
           if switchInfo["sdk_inst"]:
              nx_sdk_py.NxSdk.__swig_destroy__(switchInfo["sdk_inst"])
           switchInfo["sdk_inst"] = 0
           switchInfo["tracer"]   = 0
           switchInfo_lock.rdUnlock()


###
# To load switch info into a dictionary from
# switch_details.json file. 
###
def loadSwitchInfo():
    global switchInfo_dict

    switchFileInfo = {}
    app_name = os.path.basename(__file__)

    if switchInfo_dict:
        print "\n\nTime: %s\n" % datetime.datetime.now()
        print "{0:15} | {1:25} | {2:10} | {3:10} | {4:10}".format("Switch", "Addr:Port", "SDK Inst", "Events Cnt", "Status")
        print "----------------------------------------------------------------------------------"
        switchInfo_lock.rdLock()
        for switch in switchInfo_dict:
            sdk_inst     = "No"
            is_connected = "-" 
            if switchInfo_dict[switch]["sdk_inst"]:
               sdk_inst = "Yes"
               if switchInfo_dict[switch]["sdk_inst"].getRemoteConnStatus() == nx_sdk_py.UP:
                  is_connected = "Yes"
            print "{0:15} | {1:25} | {2:10} | {3:10} | {4:10}\n".format(switchInfo_dict[switch]["name"], \
                    switch + ":" + str(switchInfo_dict[switch]["port"]),\
                  sdk_inst, switchInfo_dict[switch]["event_cnt"], switchInfo_dict[switch]["reason"])
        switchInfo_lock.rdUnlock()

    with open("switch_details.json", 'r') as switch_json_file:
         switchFileInfo = json.loads(switch_json_file.read())["switchInfo"]

    ### Add new switches to the list     
    got_wr_lock = False
    for switch_det in switchFileInfo:     
        addr = str(switch_det["addr"])
        switch_det_port = 0

        ### check if app is part of the switchInfo
        found_switch = False
        for port_apps in switch_det["port-apps"]:
            if app_name == port_apps["app"]:
               switch_det_port = port_apps["port"]
               found_switch = True
               break

        if not found_switch:
           continue

        switchInfo_lock.rdLock()
        if addr not in switchInfo_dict:
           switchInfo_dict[addr] = {}
           switchInfo_lock.rdUnlock()
           switchInfo_lock.wrLock()
           got_wr_lock = True
        elif "port" in switchInfo_dict[addr] and switchInfo_dict[addr]["port"] != switch_det_port:
           print "Err: Wrong port given: " + str(switch_det_port) + " as Switch " + addr + \
                 " already attached to port " + str(switchInfo_dict[addr]["port"]) + "\n"  
           switchInfo_lock.rdUnlock()
           continue
        switchInfo_dict[addr]["port"]   = switch_det_port
        switchInfo_dict[addr]["name"]   = switch_det["name"]
        switchInfo_dict[addr]["done"]   = True
        if "reason" not in switchInfo_dict[addr]:
           switchInfo_dict[addr]["reason"] = ""
        if "event_cnt" not in switchInfo_dict[addr]:   
           switchInfo_dict[addr]["event_cnt"] = 0
        if "sdk_inst" not in switchInfo_dict[addr]:
           switchInfo_dict[addr]["sdk_inst"] = 0

        if got_wr_lock:
           switchInfo_lock.wrUnlock()
           switchInfo_lock.rdLock()

        ### SDK inst does not exist hence try to init with NX-SDK.   
        if not switchInfo_dict[addr]["sdk_inst"]:
           sdk_thread = threading.Thread(target=sdkThread, \
                         args=(str(addr), switch_det_port, \
                         switchInfo_dict[addr]))
           sdk_thread.start()           
        switchInfo_lock.rdUnlock()

    ### Check for deleted switches and remove them
    delete_switch_list = []
    for switch_addr in switchInfo_dict:
        switch_det = switchInfo_dict[switch_addr]
        if "done" in switch_det:
           switch_det.pop("done")
        else:
           ### Switch has been deleted remove it.
           delete_switch_list.append(switch_addr)
    got_lock = False
    if delete_switch_list:
       got_lock = True
       switchInfo_lock.wrLock()           
    for switch_addr in delete_switch_list:
        if switch_addr in switchInfo_dict:
           if switchInfo_dict[switch_addr]["sdk_inst"]: 
              switchInfo_dict[switch_addr]["sdk_inst"].stopEventLoop()
              #while switchInfo_dict[switch_addr]["sdk_inst"]:
              time.sleep(2)
           switchInfo_dict.pop(switch_addr)       
           print "Deleted Switch " + switch_addr + " from the List"
    if got_lock:
       switchInfo_lock.wrUnlock()           

while True:
    loadSwitchInfo()
    time.sleep(2)
    adj_dict_lock.rdLock()
    dup_str = ""
    for item in dupHost_dict:
        (intf, addr) = item.split(":")
        start_time = dupHost_dict[item]
        if (time.time() - start_time) > 20:
            if intf in adj_dict:
               if addr in adj_dict[intf]:
                  adj_info = adj_dict[intf][addr]
                  if len(adj_info["switch"]) > 1:
                     dup_str = "Dup Host detected [" + adj_info["vrf"] + "] " + adj_info["addr"] + \
                               " Mac: " + adj_info["mac"] + "L3 Intf: " + adj_info["intf"] + " Phy Intf: " + \
                               adj_info["phy"] + " in switches ["
                     first_time = True           
                     for switch in adj_info["switch"]:
                         if first_time:
                            dup_str += switch
                            first_time = False
                         else:   
                            dup_str += ", " + switch 
                     dup_str += "]"    
            if dup_str:
               print dup_str + "\n"
               dup_str = ""
    adj_dict_lock.rdUnlock()
