\hypertarget{classnxos_1_1_nx_l3_route}{}\section{nxos\+:\+:Nx\+L3\+Route Class Reference}
\label{classnxos_1_1_nx_l3_route}\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}


Abstract Route Interface to Add/\+Delete and receive Route updates from N\+X\+OS R\+IB.  




{\ttfamily \#include $<$nx\+\_\+rib\+\_\+mgr.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route_abb3762fb6629ba1900e877555cbb69dc}{$\sim$\+Nx\+L3\+Route}} ()
\item 
virtual std\+::string \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a06ed660337e8b919dd801267957497d7}{get\+Vrf\+Name}} ()=0
\item 
virtual std\+::string \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a3176245539589bf745ce1d196975b3c9}{get\+Address}} ()=0
\item 
virtual unsigned int \mbox{\hyperlink{classnxos_1_1_nx_l3_route_aaafa1d34e62297bbed574995ff48dba9}{get\+Mask\+Len}} ()=0
\item 
virtual unsigned int \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a5e402096d7ff280b6f4d334b3bd954d4}{get\+L3\+Next\+Hop\+Count}} ()=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a79bd39e19c238b12f0af22d2781059cd}{get\+L3\+Next\+Hop}} (const std\+::string \&address, const std\+::string \&intf\+Name=\char`\"{}\char`\"{})=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a7877c5328b1706acbbe5d8dbc6c94f4e}{get\+L3\+Next\+Hop}} (bool from\+First=false)=0
\item 
virtual \mbox{\hyperlink{nx__common_8h_af9a9040b7681199d386e94eb888018cb}{nxos\+::event\+\_\+type\+\_\+e}} \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a9ca0b236a35cc616753e09e620b6b02f}{get\+Event}} ()=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a1680de6899caf8fa1be3ecfad131cd25}{operator==}} (\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&route\+\_\+obj) const =0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a945f75e6656623cbf8cf23b6ab7e01d3}{operator!=}} (\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&route\+\_\+obj) const =0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a6dc5e111e8e8ad48aa028fc65cc483b9}{equal}} (\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&route\+\_\+obj) const =0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a7ae92c958f54c6e85579eb6ef81f30b3}{add\+L3\+Direct\+Next\+Hop}} (const std\+::string \&next\+Hop\+Addr, const std\+::string \&intf\+Name, uint8\+\_\+t preference)=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a8733985ca139f4d33215f032c4932be7}{add\+L3\+Recursive\+Next\+Hop}} (const std\+::string \&next\+Hop\+Addr, uint8\+\_\+t preference)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_l3_route_a8c0708c54d5bb8ce94f80e0edd43880c}{del\+L3\+Next\+Hop}} (const std\+::string \&nex\+Hop\+Address, const std\+::string \&intf\+Name=\char`\"{}\char`\"{})=0
\item 
virtual std\+::string \mbox{\hyperlink{classnxos_1_1_nx_l3_route_acff8f87abd7dcdc002c97a0ca04bf815}{get\+L3\+Prefix}} () const =0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Abstract Route Interface to Add/\+Delete and receive Route updates from N\+X\+OS R\+IB. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_abb3762fb6629ba1900e877555cbb69dc}\label{classnxos_1_1_nx_l3_route_abb3762fb6629ba1900e877555cbb69dc}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!````~Nx\+L3\+Route@{$\sim$\+Nx\+L3\+Route}}
\index{````~Nx\+L3\+Route@{$\sim$\+Nx\+L3\+Route}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{$\sim$\+Nx\+L3\+Route()}{~NxL3Route()}}
{\footnotesize\ttfamily virtual nxos\+::\+Nx\+L3\+Route\+::$\sim$\+Nx\+L3\+Route (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Destructor 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a7ae92c958f54c6e85579eb6ef81f30b3}\label{classnxos_1_1_nx_l3_route_a7ae92c958f54c6e85579eb6ef81f30b3}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!add\+L3\+Direct\+Next\+Hop@{add\+L3\+Direct\+Next\+Hop}}
\index{add\+L3\+Direct\+Next\+Hop@{add\+L3\+Direct\+Next\+Hop}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{add\+L3\+Direct\+Next\+Hop()}{addL3DirectNextHop()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}}$\ast$ nxos\+::\+Nx\+L3\+Route\+::add\+L3\+Direct\+Next\+Hop (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{next\+Hop\+Addr,  }\item[{const std\+::string \&}]{intf\+Name,  }\item[{uint8\+\_\+t}]{preference }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To add a direct next-\/hop to a route. Changes will take effect when send\+My\+L3\+Routes\+To\+Rib is called. post\+My\+L3\+Route\+Cb is called after send\+My\+L3\+Routes\+To\+Rib called to signal that route changes are done.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em next\+Hop\+Addr} & Address of the next-\/hop as a string. \\
\hline
\mbox{\tt in}  & {\em intf\+Name} & Egress interface name as a string. \\
\hline
\mbox{\tt in}  & {\em preference} & Preference value score is inverted where lower is more preferred. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an object of type \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} to use to further configure the next-\/hop if needed.
\end{DoxyReturn}
\begin{DoxyVerb}Write API - NX-SDK Applications can use this API only if security profile with permit (or) throttle is 
            enabled for that application. Using this API without the appropriate security profiles will
            throw an exception. Refer to readmes/security_profiles.md for more info in NX-SDK Git repo.
\end{DoxyVerb}



\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->addL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     NxL3NextHop *nh = route->addL3DirectNextHop(\textcolor{stringliteral}{"10.1.1.3"}, 
                                                 \textcolor{stringliteral}{"Eth1/3"} 12);
     \textcolor{keywordtype}{bool} result = route->sendMyL3RoutesToRib(AF\_IPV4);

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.addL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     next\_hop = route.addL3DirectNextHop(\textcolor{stringliteral}{"10.1.1.3"}, \textcolor{stringliteral}{"Eth1/3"}, 12)
     result = ribMgr.sendMyL3RoutesToRib(nx\_sdk\_py.AF\_IPV4)
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a8733985ca139f4d33215f032c4932be7}\label{classnxos_1_1_nx_l3_route_a8733985ca139f4d33215f032c4932be7}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!add\+L3\+Recursive\+Next\+Hop@{add\+L3\+Recursive\+Next\+Hop}}
\index{add\+L3\+Recursive\+Next\+Hop@{add\+L3\+Recursive\+Next\+Hop}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{add\+L3\+Recursive\+Next\+Hop()}{addL3RecursiveNextHop()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}}$\ast$ nxos\+::\+Nx\+L3\+Route\+::add\+L3\+Recursive\+Next\+Hop (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{next\+Hop\+Addr,  }\item[{uint8\+\_\+t}]{preference }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To add a recursive next-\/hop to a route. Changes will take effect after send\+My\+L3\+Routes\+To\+Rib is called. post\+My\+L3\+Route\+Cb is called after send\+My\+L3\+Routes\+To\+Rib is called to signal that route changes are done. post\+L3\+Recursive\+Next\+Hop\+Cb is called after send\+My\+L3\+Routes\+To\+Rib to signal changes to the next hop.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em next\+Hop\+Addr} & Address of the next-\/hop as a string. \\
\hline
\mbox{\tt in}  & {\em preference} & Preference value score is inverted where lower is more preferred. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an object of type \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} to use to further configure the next-\/hop if needed.
\end{DoxyReturn}
\begin{DoxyVerb}Write API - NX-SDK Applications can use this API only if security profile with permit (or) throttle is 
            enabled for that application. Using this API without the appropriate security profiles will
            throw an exception. Refer to readmes/security_profiles.md for more info in NX-SDK Git repo.
\end{DoxyVerb}



\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->addL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     NxL3NextHop *nh = route->addL3RecursiveNextHop(\textcolor{stringliteral}{"10.1.1.3"}, 12);
     \textcolor{keywordtype}{bool} result = route->sendMyL3RoutesToRib(AF\_IPV4);

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.addL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     next\_hop = route.addL3RecursiveNextHop(\textcolor{stringliteral}{"10.1.1.3"}, 12)
     result = ribMgr.sendMyL3RoutesToRib(nx\_sdk\_py.AF\_IPV4)
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a8c0708c54d5bb8ce94f80e0edd43880c}\label{classnxos_1_1_nx_l3_route_a8c0708c54d5bb8ce94f80e0edd43880c}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!del\+L3\+Next\+Hop@{del\+L3\+Next\+Hop}}
\index{del\+L3\+Next\+Hop@{del\+L3\+Next\+Hop}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{del\+L3\+Next\+Hop()}{delL3NextHop()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+L3\+Route\+::del\+L3\+Next\+Hop (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{nex\+Hop\+Address,  }\item[{const std\+::string \&}]{intf\+Name = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To delete a Layer3 route next-\/hop. Changes will take effect after send\+My\+L3\+Routes\+To\+Rib is called. post\+My\+L3\+Route\+Cb is called after send\+My\+L3\+Routes\+To\+Rib is called to signal that route changes are complete.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em next\+Hop\+Address} & Address of the next-\/hop as a string.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an object of type \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} to use to further configure the next-\/hop if needed.
\end{DoxyReturn}
\begin{DoxyVerb}Write API - NX-SDK Applications can use this API only if security profile with permit (or) throttle is 
            enabled for that application. Using this API without the appropriate security profiles will
            throw an exception. Refer to readmes/security_profiles.md for more info in NX-SDK Git repo.
\end{DoxyVerb}
 
\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3RouteDetail(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     NxL3NextHop *nh = route->delL3NextHop(\textcolor{stringliteral}{"10.1.1.3"});
     \textcolor{keywordtype}{bool} result = route->sendMyL3RoutesToRib(AF\_IPV4);

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.addL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     next\_hop = route.delL3NextHop(\textcolor{stringliteral}{"10.1.1.3"})
     result = ribMgr.sendMyL3RoutesToRib(nx\_sdk\_py.AF\_IPV4)
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a6dc5e111e8e8ad48aa028fc65cc483b9}\label{classnxos_1_1_nx_l3_route_a6dc5e111e8e8ad48aa028fc65cc483b9}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!equal@{equal}}
\index{equal@{equal}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{equal()}{equal()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+L3\+Route\+::equal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&}]{route\+\_\+obj }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Test equality of route objects.

\begin{DoxyReturn}{Returns}
true if equality property holds, false otherwise
\end{DoxyReturn}

\begin{DoxyCode}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a3176245539589bf745ce1d196975b3c9}\label{classnxos_1_1_nx_l3_route_a3176245539589bf745ce1d196975b3c9}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+Address@{get\+Address}}
\index{get\+Address@{get\+Address}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+Address()}{getAddress()}}
{\footnotesize\ttfamily virtual std\+::string nxos\+::\+Nx\+L3\+Route\+::get\+Address (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the Address of the L3 Route.

\begin{DoxyReturn}{Returns}
Address of the Route(string)
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         cout << \textcolor{stringliteral}{"Route Address: "} << route->getAddress();
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        print \textcolor{stringliteral}{"Route Address: %s"} % route.getAddress()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a9ca0b236a35cc616753e09e620b6b02f}\label{classnxos_1_1_nx_l3_route_a9ca0b236a35cc616753e09e620b6b02f}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+Event@{get\+Event}}
\index{get\+Event@{get\+Event}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+Event()}{getEvent()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{nx__common_8h_af9a9040b7681199d386e94eb888018cb}{nxos\+::event\+\_\+type\+\_\+e}} nxos\+::\+Nx\+L3\+Route\+::get\+Event (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the type of Event(\+Add, Update, Delete etc) when there is a change to a tracked L3 Route. Should be used only in Rib Handler Callbacks like post\+L3\+Route\+Cb(). If used outside of R\+IB Handler Callbacks its set to N\+O\+\_\+\+E\+V\+E\+NT.

\begin{DoxyReturn}{Returns}
Route Event Type(event\+\_\+type\+\_\+e)
\end{DoxyReturn}

\begin{DoxyCode}
C++:
   \textcolor{keyword}{class }myRibMgrMgrHandler : \textcolor{keyword}{public} NxRibMgrHandler \{
      \textcolor{keyword}{public}:
         \textcolor{keywordtype}{bool} postL3RouteCb(NxL3Route *route) \{
              cout << \textcolor{stringliteral}{"Route Event: "} << route->getEvent();
         \}
   \};
Python:
   \textcolor{keyword}{class }pyRibHandler(nx\_sdk\_py.NxRibMgrHandler):
\textcolor{preprocessor}{   ### Overloaded Callback to get Route events}
         def postL3RouteCb(self, nxroute):
             print "Route Event: %d" % nxroute.\mbox{\hyperlink{classnxos_1_1_nx_l3_route_a9ca0b236a35cc616753e09e620b6b02f}{getEvent}}()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a79bd39e19c238b12f0af22d2781059cd}\label{classnxos_1_1_nx_l3_route_a79bd39e19c238b12f0af22d2781059cd}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+L3\+Next\+Hop@{get\+L3\+Next\+Hop}}
\index{get\+L3\+Next\+Hop@{get\+L3\+Next\+Hop}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+L3\+Next\+Hop()}{getL3NextHop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}}$\ast$ nxos\+::\+Nx\+L3\+Route\+::get\+L3\+Next\+Hop (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{address,  }\item[{const std\+::string \&}]{intf\+Name = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the Next\+Hop for this L3 Route if it exists by the specified address.

\begin{DoxyReturn}{Returns}
a pointer to \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} if it exists. N\+U\+LL if not.
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;
     NxL3NextHop  *nh;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         nh = route->getL3NextHop(\textcolor{stringliteral}{"20.1.1.1"});
         \textcolor{keywordflow}{if} (nh) \{
             cout << \textcolor{stringliteral}{"NextHop "} << nh->getAddress() << \textcolor{stringliteral}{" exists for route "}
                  << route->getAddress();
         \} \textcolor{keywordflow}{else} \{
             cout << \textcolor{stringliteral}{"NextHop "} << nh->getAddress() << \textcolor{stringliteral}{" does not exist "}
                  \textcolor{stringliteral}{"for route "} << route->getAddress();
         \}
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        nh = route.getL3NextHop(\textcolor{stringliteral}{"20.1.1.1"})
        \textcolor{keywordflow}{if} nh:
           print \textcolor{stringliteral}{"NextHop %s exists for route %s"} % \(\backslash\)
                 (nh.getAddress(), route.getAddress())
        \textcolor{keywordflow}{else}:
           print \textcolor{stringliteral}{"NextHop %s does not exist for route %s"} % \(\backslash\)
                 (nh.getAddress(), route.getAddress())
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a7877c5328b1706acbbe5d8dbc6c94f4e}\label{classnxos_1_1_nx_l3_route_a7877c5328b1706acbbe5d8dbc6c94f4e}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+L3\+Next\+Hop@{get\+L3\+Next\+Hop}}
\index{get\+L3\+Next\+Hop@{get\+L3\+Next\+Hop}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+L3\+Next\+Hop()}{getL3NextHop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}}$\ast$ nxos\+::\+Nx\+L3\+Route\+::get\+L3\+Next\+Hop (\begin{DoxyParamCaption}\item[{bool}]{from\+First = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the first Next\+Hop for this L3 Route. To get all the Next\+Hops call this A\+PI in a while loop. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em from\+First} & At anytime, to get or start from first Next\+Hop, set from\+Frist to True and then call it in a while loop with from\+First to False to loop through the list if there are more than one Nexthop. Refer to usage. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to \mbox{\hyperlink{classnxos_1_1_nx_l3_next_hop}{Nx\+L3\+Next\+Hop}} if it exists N\+U\+LL if not.
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;
     NxL3NextHop  *nh;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         nh = route->getL3NextHop(\textcolor{keyword}{true});
         \textcolor{keywordflow}{while} (nh) \{
             cout << \textcolor{stringliteral}{"NextHop "} << nh->getAddress();
             nh = route->getL3NextHop();
         \}
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        nh = route.getL3NextHop(True)
        \textcolor{keywordflow}{while} nh:
            print \textcolor{stringliteral}{"NextHop %s"} % nh.getAddress()
            nh = route.getL3NextHop()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a5e402096d7ff280b6f4d334b3bd954d4}\label{classnxos_1_1_nx_l3_route_a5e402096d7ff280b6f4d334b3bd954d4}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+L3\+Next\+Hop\+Count@{get\+L3\+Next\+Hop\+Count}}
\index{get\+L3\+Next\+Hop\+Count@{get\+L3\+Next\+Hop\+Count}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+L3\+Next\+Hop\+Count()}{getL3NextHopCount()}}
{\footnotesize\ttfamily virtual unsigned int nxos\+::\+Nx\+L3\+Route\+::get\+L3\+Next\+Hop\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the count of Next\+Hops for this L3 Route. Returns 0 if there are no nexthops for the route which happens in the case of route Delete.

\begin{DoxyReturn}{Returns}
Count of Next\+Hops in a Route(unsigned int)
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         cout << \textcolor{stringliteral}{"Route NextHop count: "} << route->getL3NextHopCount();
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        print \textcolor{stringliteral}{"Route NextHop Count: %d"} % route.getL3NextHopCount()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_acff8f87abd7dcdc002c97a0ca04bf815}\label{classnxos_1_1_nx_l3_route_acff8f87abd7dcdc002c97a0ca04bf815}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+L3\+Prefix@{get\+L3\+Prefix}}
\index{get\+L3\+Prefix@{get\+L3\+Prefix}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+L3\+Prefix()}{getL3Prefix()}}
{\footnotesize\ttfamily virtual std\+::string nxos\+::\+Nx\+L3\+Route\+::get\+L3\+Prefix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the IP prefix string of the L3 Route.

\begin{DoxyReturn}{Returns}
IP prefix string of the L3 Route
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         cout << \textcolor{stringliteral}{"Route Prefix: "} << route->getL3Prefix();
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        print \textcolor{stringliteral}{"Route Prefix: %d"} % route.getL3Prefix()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_aaafa1d34e62297bbed574995ff48dba9}\label{classnxos_1_1_nx_l3_route_aaafa1d34e62297bbed574995ff48dba9}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+Mask\+Len@{get\+Mask\+Len}}
\index{get\+Mask\+Len@{get\+Mask\+Len}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+Mask\+Len()}{getMaskLen()}}
{\footnotesize\ttfamily virtual unsigned int nxos\+::\+Nx\+L3\+Route\+::get\+Mask\+Len (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the masklen of the L3 Route.

\begin{DoxyReturn}{Returns}
Mask\+Len of the Route(unsigned int)
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         cout << \textcolor{stringliteral}{"Route MaskLen: "} << route->getMaskLen();
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        print \textcolor{stringliteral}{"Route MaskLen: %d"} % route.getMaskLen()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a06ed660337e8b919dd801267957497d7}\label{classnxos_1_1_nx_l3_route_a06ed660337e8b919dd801267957497d7}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!get\+Vrf\+Name@{get\+Vrf\+Name}}
\index{get\+Vrf\+Name@{get\+Vrf\+Name}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{get\+Vrf\+Name()}{getVrfName()}}
{\footnotesize\ttfamily virtual std\+::string nxos\+::\+Nx\+L3\+Route\+::get\+Vrf\+Name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the V\+RF Name of the L3 Route.

\begin{DoxyReturn}{Returns}
V\+RF Name(string)
\end{DoxyReturn}

\begin{DoxyCode}
C++:
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}
\textcolor{preprocessor}{     #include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}

     NxL3Route    *route;

     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);
     ribMgr = sdk->getRibMgr();

     route = ribMgr->getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"});
     \textcolor{keywordflow}{if} (route) \{
         cout << \textcolor{stringliteral}{"Route VRfName: "} << route->getVrfName();
     \}

Python:
     \textcolor{keyword}{import} nx\_sdk\_py
     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
     ribMgr = sdk.getRibMgr()

     route = ribMgr.getL3Route(\textcolor{stringliteral}{"10.1.1.1"}, 24, \textcolor{stringliteral}{"default"})
     \textcolor{keywordflow}{if} route:
        print \textcolor{stringliteral}{"Route VrfName: %s"} % route.getVrfName()
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a945f75e6656623cbf8cf23b6ab7e01d3}\label{classnxos_1_1_nx_l3_route_a945f75e6656623cbf8cf23b6ab7e01d3}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+L3\+Route\+::operator!= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&}]{route\+\_\+obj }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
true if inequality property holds, false otherwise
\end{DoxyReturn}

\begin{DoxyCode}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_l3_route_a1680de6899caf8fa1be3ecfad131cd25}\label{classnxos_1_1_nx_l3_route_a1680de6899caf8fa1be3ecfad131cd25}} 
\index{nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}!operator==@{operator==}}
\index{operator==@{operator==}!nxos\+::\+Nx\+L3\+Route@{nxos\+::\+Nx\+L3\+Route}}
\subsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+L3\+Route\+::operator== (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} const \&}]{route\+\_\+obj }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
true if equality property holds, false otherwise
\end{DoxyReturn}

\begin{DoxyCode}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{nx__rib__mgr_8h}{nx\+\_\+rib\+\_\+mgr.\+h}}\end{DoxyCompactItemize}
