\hypertarget{classnxos_1_1_nx_mac_mgr}{}\doxysection{nxos\+::Nx\+Mac\+Mgr Class Reference}
\label{classnxos_1_1_nx_mac_mgr}\index{nxos::NxMacMgr@{nxos::NxMacMgr}}


Abstract N\+X-\/\+S\+DK M\+AC Manager interface to gain access to N\+X\+OS M\+AC address table.  




{\ttfamily \#include $<$nx\+\_\+mac\+\_\+mgr.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a850cc17a798501d3e5e1aea213bb2a41}{$\sim$\+Nx\+Mac\+Mgr}} ()
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a688eeadbbf960420b24eb13883f77008}{add\+Static\+Mac}} (const std\+::string \&mac\+Addr, const unsigned int vlan, const std\+::string \&intf\+\_\+name)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_aa8853103d4b94e6153f2b0cc5f130b77}{del\+Static\+Mac}} (const std\+::string \&mac\+Addr, const unsigned int vlan)=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_mac}{Nx\+Mac}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_ab205e4819bfc3eca4396a194400d9b12}{get\+Mac}} (const std\+::string \&mac\+Addr, const unsigned int vlan, bool clear\+Buffer=false)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a5f4d2d56e21e3ae39969fa67774779d8}{watch\+All\+Mac}} (bool download=true)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_aac2eae84327fa4a94616d214ac779fac}{unwatch\+All\+Mac}} ()=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a12dde38c22d9a27e1e3bde318d418134}{watch\+Mac}} (const unsigned int vlan, const std\+::string \&mac\+Addr=\char`\"{}\char`\"{}, bool download=true)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_af3a7878b8b604baa1e388c9b9ea9c952}{unwatch\+Mac}} (const unsigned int vlan, const std\+::string \&mac\+Addr=\char`\"{}\char`\"{})=0
\item 
virtual void \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}{set\+Mac\+Mgr\+Handler}} (\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}} $\ast$handler)=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a94e3fcb535f109501d319d72a24bdead}{get\+Mac\+Mgr\+Handler}} ()=0
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Abstract N\+X-\/\+S\+DK M\+AC Manager interface to gain access to N\+X\+OS M\+AC address table. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a850cc17a798501d3e5e1aea213bb2a41}\label{classnxos_1_1_nx_mac_mgr_a850cc17a798501d3e5e1aea213bb2a41}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!````~NxMacMgr@{$\sim$NxMacMgr}}
\index{````~NxMacMgr@{$\sim$NxMacMgr}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{$\sim$NxMacMgr()}{~NxMacMgr()}}
{\footnotesize\ttfamily virtual nxos\+::\+Nx\+Mac\+Mgr\+::$\sim$\+Nx\+Mac\+Mgr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Destructor

To delete the M\+AC manager instance and its associated objects gracefully. Its cleaned on delete sdk too. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a688eeadbbf960420b24eb13883f77008}\label{classnxos_1_1_nx_mac_mgr_a688eeadbbf960420b24eb13883f77008}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!addStaticMac@{addStaticMac}}
\index{addStaticMac@{addStaticMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{addStaticMac()}{addStaticMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::add\+Static\+Mac (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{mac\+Addr,  }\item[{const unsigned int}]{vlan,  }\item[{const std\+::string \&}]{intf\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To add static mac


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mac\+Addr} & Mac address to add \\
\hline
\mbox{\texttt{ in}}  & {\em vlan} & \+: vlan value \\
\hline
\mbox{\texttt{ in}}  & {\em intf\+\_\+name} & Interface name that connects to this mac.\\
\hline
\end{DoxyParams}
Write A\+PI -\/ N\+X-\/\+S\+DK Applications can use this A\+PI only if security profile with permit (or) throttle is enabled for that application. Using this A\+PI without the appropriate security profiles will throw an exception. Refer to readmes/security\+\_\+profiles.\+md for more info in N\+X-\/\+S\+DK Git repo.

\begin{DoxyReturn}{Returns}
True -\/ if successful. False -\/ if it not successful. ~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxMac *mac;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (macMgr) \{}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} ret = macMgr-\/>addStaticMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2, \textcolor{stringliteral}{"{}eth1/1"{}});}
\DoxyCodeLine{         \textcolor{keywordflow}{if} (ret) \{  }
\DoxyCodeLine{             cout << \textcolor{stringliteral}{"{}Static MAC added\(\backslash\)n"{}};}
\DoxyCodeLine{         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{             cout << \textcolor{stringliteral}{"{}Failed to add static mac\(\backslash\)n"{}};}
\DoxyCodeLine{         \}}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     macMgr = sdk.getMacMgr()}
\DoxyCodeLine{     \textcolor{keywordflow}{if} macMgr:}
\DoxyCodeLine{         ret = macMgr.addStaticMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2, \textcolor{stringliteral}{"{}eth1/1"{}})}
\DoxyCodeLine{         \textcolor{keywordflow}{if} ret:}
\DoxyCodeLine{            print \textcolor{stringliteral}{"{}static mac added\(\backslash\)n"{}}}
\DoxyCodeLine{         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{            print \textcolor{stringliteral}{"{}Failed to add static mac\(\backslash\)n"{}}}
\end{DoxyCode}

\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em E\+R\+R\+\_\+\+I\+N\+V\+A\+L\+ID} & mac\+Addr or vlan or intf\+\_\+name is invalid. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_aa8853103d4b94e6153f2b0cc5f130b77}\label{classnxos_1_1_nx_mac_mgr_aa8853103d4b94e6153f2b0cc5f130b77}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!delStaticMac@{delStaticMac}}
\index{delStaticMac@{delStaticMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{delStaticMac()}{delStaticMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::del\+Static\+Mac (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{mac\+Addr,  }\item[{const unsigned int}]{vlan }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To delete static mac 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mac\+Addr} & Mac address to remove \\
\hline
\mbox{\texttt{ in}}  & {\em vlan} & \+: vlan value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful. 
\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxMac *mac;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (macMgr) \{}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} ret = macMgr-\/>delStaticMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2, \textcolor{stringliteral}{"{}eth1/1"{}});}
\DoxyCodeLine{         \textcolor{keywordflow}{if} (ret) \{  }
\DoxyCodeLine{             cout << \textcolor{stringliteral}{"{}Static MAC deleted\(\backslash\)n"{}};}
\DoxyCodeLine{         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{             cout << \textcolor{stringliteral}{"{}Failed to delete static mac\(\backslash\)n"{}};}
\DoxyCodeLine{         \}}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     macMgr = sdk.getMacMgr()}
\DoxyCodeLine{     \textcolor{keywordflow}{if} macMgr:}
\DoxyCodeLine{         ret = macMgr.addStaticMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2, \textcolor{stringliteral}{"{}eth1/1"{}})}
\DoxyCodeLine{         \textcolor{keywordflow}{if} ret:}
\DoxyCodeLine{            print \textcolor{stringliteral}{"{}static mac deleted\(\backslash\)n"{}}}
\DoxyCodeLine{         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{            print \textcolor{stringliteral}{"{}Failed to delete static mac\(\backslash\)n"{}}}
\end{DoxyCode}

\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em E\+R\+R\+\_\+\+I\+N\+V\+A\+L\+ID} & mac\+Addr or vlan is invalid. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_ab205e4819bfc3eca4396a194400d9b12}\label{classnxos_1_1_nx_mac_mgr_ab205e4819bfc3eca4396a194400d9b12}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!getMac@{getMac}}
\index{getMac@{getMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{getMac()}{getMac()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_mac}{Nx\+Mac}}$\ast$ nxos\+::\+Nx\+Mac\+Mgr\+::get\+Mac (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{mac\+Addr,  }\item[{const unsigned int}]{vlan,  }\item[{bool}]{clear\+Buffer = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the M\+AC object from a given M\+AC address and vlan. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mac\+Addr} & M\+AC address in string. \\
\hline
\mbox{\texttt{ in}}  & {\em vlan} & vlan in unsigned int \\
\hline
\mbox{\texttt{ in}}  & {\em clear\+Buffer} & \mbox{[}Optional\mbox{]} If the M\+AC is present, \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_ab205e4819bfc3eca4396a194400d9b12}{get\+Mac()}} creates a new M\+AC object. \mbox{[}Recommended\mbox{]} App owners must free/destroy the M\+AC object once done. If they fail to free it, N\+X\+S\+DK will store the object until it is freed. When clear\+Buffer flag is set to True it will free all the previously created M\+AC objects. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classnxos_1_1_nx_mac}{Nx\+Mac}} Object if it exists. N\+U\+LL if it does not exist.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxMac *mac;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (macMgr) \{}
\DoxyCodeLine{         mac = macMgr-\/>getMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2);}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     macMgr = sdk.getMacMgr()}
\DoxyCodeLine{     \textcolor{keywordflow}{if} macMgr:}
\DoxyCodeLine{         mac = macMgr.getMac(\textcolor{stringliteral}{"{}1.1.1"{}}, 2)}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em E\+R\+R\+\_\+\+I\+N\+V\+A\+L\+ID} & mac\+Addr or vlan is invalid. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a94e3fcb535f109501d319d72a24bdead}\label{classnxos_1_1_nx_mac_mgr_a94e3fcb535f109501d319d72a24bdead}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!getMacMgrHandler@{getMacMgrHandler}}
\index{getMacMgrHandler@{getMacMgrHandler}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{getMacMgrHandler()}{getMacMgrHandler()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}}$\ast$ nxos\+::\+Nx\+Mac\+Mgr\+::get\+Mac\+Mgr\+Handler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the Handler object registered with M\+AC Manager.

\begin{DoxyReturn}{Returns}
user defined \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}} Obj if registered using set\+Mac\+Mgr\+Handler (or) N\+U\+LL. 
\end{DoxyReturn}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}\label{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!setMacMgrHandler@{setMacMgrHandler}}
\index{setMacMgrHandler@{setMacMgrHandler}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{setMacMgrHandler()}{setMacMgrHandler()}}
{\footnotesize\ttfamily virtual void nxos\+::\+Nx\+Mac\+Mgr\+::set\+Mac\+Mgr\+Handler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}} $\ast$}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Users to overload M\+AC Manager Handler class to handle registered events like M\+AC updates and register the handler object with M\+AC manager to handle mac events. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_handler}{Nx\+Mac\+Mgr\+Handler}}} & object with user overloaded functions to handle mac events.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myMacMgrHandler : \textcolor{keyword}{public} NxMacMgrHandler \{}
\DoxyCodeLine{      \textcolor{keyword}{public}:}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} postMacCb(NxMac *mac) \{}
\DoxyCodeLine{              \textcolor{comment}{// Do your action}}
\DoxyCodeLine{         \}}
\DoxyCodeLine{   \};}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{        NxSdk    *sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{        NxMacMgr *macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{        NxMacMgrHandler *mymaccb = \textcolor{keyword}{new} myMacMgrHandler();}
\DoxyCodeLine{        macMgr-\/>setMacMgrHandler(mymaccb);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myMacMgrHandler(nx\_sdk\_py.NxMacMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{   \#\#\# Overloaded Callback to get MAC events}}
\DoxyCodeLine{         def postMacCb(self, nxmac):}
\DoxyCodeLine{\textcolor{preprocessor}{             \# Do your action here}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       macMgr = sdk.getMacMgr()}
\DoxyCodeLine{       mymaccb = myMacMgrHandler()}
\DoxyCodeLine{       macMgr.\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}{setMacMgrHandler}}(mymaccb)}
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_aac2eae84327fa4a94616d214ac779fac}\label{classnxos_1_1_nx_mac_mgr_aac2eae84327fa4a94616d214ac779fac}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!unwatchAllMac@{unwatchAllMac}}
\index{unwatchAllMac@{unwatchAllMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{unwatchAllMac()}{unwatchAllMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::unwatch\+All\+Mac (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To unsubscribe for all M\+AC updates.

\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxMac *mac;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     macMgr-\/>unwatchAllMac();}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     macMgr = sdk.getMacMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     macMgr.unwatchAllMac()}
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_af3a7878b8b604baa1e388c9b9ea9c952}\label{classnxos_1_1_nx_mac_mgr_af3a7878b8b604baa1e388c9b9ea9c952}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!unwatchMac@{unwatchMac}}
\index{unwatchMac@{unwatchMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{unwatchMac()}{unwatchMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::unwatch\+Mac (\begin{DoxyParamCaption}\item[{const unsigned int}]{vlan,  }\item[{const std\+::string \&}]{mac\+Addr = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To un-\/subscribe for any updates to this vlan and mac address. To un-\/subscribe all M\+AC address for specific vlan, use mac\+Addr as \char`\"{}\char`\"{}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vlan} & vlan in unsigned int. \\
\hline
\mbox{\texttt{ in}}  & {\em mac\+Addr} & \mbox{[}Optional\mbox{]} M\+AC address in string. If not specified, \char`\"{}\char`\"{} is used to watch on all M\+AC address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxMac *mac;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     macMgr-\/>unwatchMac(2, \textcolor{stringliteral}{"{}1.1.1"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     macMgr = sdk.getMacMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     macMgr.unwatchMac(2, \textcolor{stringliteral}{"{}1.1.1"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em E\+R\+R\+\_\+\+I\+N\+V\+A\+L\+ID} & mac\+Addr or vlan is invalid. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a5f4d2d56e21e3ae39969fa67774779d8}\label{classnxos_1_1_nx_mac_mgr_a5f4d2d56e21e3ae39969fa67774779d8}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!watchAllMac@{watchAllMac}}
\index{watchAllMac@{watchAllMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{watchAllMac()}{watchAllMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::watch\+All\+Mac (\begin{DoxyParamCaption}\item[{bool}]{download = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To receive/subscribe for all M\+AC updates. On any update to any M\+AC, user overloaded post\+Mac\+Cb handler will be called.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em download} & \mbox{[}Optional\mbox{]} If set to true, all existing macs in the system will be notified to the application via the registered callback.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful. 
\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{keyword}{class }myMacMgrHandler : \textcolor{keyword}{public} NxMacMgrHandler \{}
\DoxyCodeLine{        \textcolor{keyword}{public}:}
\DoxyCodeLine{           \textcolor{keywordtype}{bool} postMacCb(NxMac *mac) \{}
\DoxyCodeLine{                cout << \textcolor{stringliteral}{"{}MAC changed"{}};}
\DoxyCodeLine{           \}}
\DoxyCodeLine{     \};}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{          NxSdk    *sdk;}
\DoxyCodeLine{          NxMacMgr *macMgr;}
\DoxyCodeLine{          NxMac    *mac;}
\DoxyCodeLine{}
\DoxyCodeLine{          NxMacMgrHandler *mymaccb = \textcolor{keyword}{new} myMacMgrHandler();}
\DoxyCodeLine{          sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{          macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{          macMgr-\/>setMacMgrHandler(mymaccb);}
\DoxyCodeLine{}
\DoxyCodeLine{          macMgr-\/>watchAllMac();}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myMacMgrHandler(nx\_sdk\_py.NxMacMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{   \#\#\# Overloaded Callback to get MAC events}}
\DoxyCodeLine{         def postMacCb(self, nxmac):}
\DoxyCodeLine{             print "{}MAC has changed"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       macMgr = sdk.getMacMgr()}
\DoxyCodeLine{       mymaccb = myMacMgrHandler()}
\DoxyCodeLine{       macMgr.\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}{setMacMgrHandler}}(mymaccb)}
\DoxyCodeLine{}
\DoxyCodeLine{       macMgr.\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a5f4d2d56e21e3ae39969fa67774779d8}{watchAllMac}}()}
\end{DoxyCode}
 
\end{DoxyReturn}
\mbox{\Hypertarget{classnxos_1_1_nx_mac_mgr_a12dde38c22d9a27e1e3bde318d418134}\label{classnxos_1_1_nx_mac_mgr_a12dde38c22d9a27e1e3bde318d418134}} 
\index{nxos::NxMacMgr@{nxos::NxMacMgr}!watchMac@{watchMac}}
\index{watchMac@{watchMac}!nxos::NxMacMgr@{nxos::NxMacMgr}}
\doxysubsubsection{\texorpdfstring{watchMac()}{watchMac()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Mac\+Mgr\+::watch\+Mac (\begin{DoxyParamCaption}\item[{const unsigned int}]{vlan,  }\item[{const std\+::string \&}]{mac\+Addr = {\ttfamily \char`\"{}\char`\"{}},  }\item[{bool}]{download = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To receive/subscribe for any updates to this vlan and mac address. On any update to this M\+AC, users overloaded post\+Mac\+Cb handler will be called. To subscribe all M\+AC address for specific vlan, use mac\+Addr as \char`\"{}\char`\"{}. N\+O\+TE\+: Forward referencing is allowed for a non created M\+AC i.\+e A\+PI can be called even if the M\+AC is not yet created. Subscribing all vlans for specific M\+AC address is not supported. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vlan} & vlan in unsigned int. \\
\hline
\mbox{\texttt{ in}}  & {\em mac\+Addr} & \mbox{[}Optional\mbox{]} M\+AC address in string. If not specified, \char`\"{}\char`\"{} is used to watch on all M\+AC address. \\
\hline
\mbox{\texttt{ in}}  & {\em download} & \mbox{[}Optional\mbox{]} Specify to get sync download of existing M\+AC objects or not (default True) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__mac__mgr_8h}{nx\_mac\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{keyword}{class }myMacMgrHandler : \textcolor{keyword}{public} NxMacMgrHandler \{}
\DoxyCodeLine{        \textcolor{keyword}{public}:}
\DoxyCodeLine{           \textcolor{keywordtype}{bool} postMacCb(NxMac *mac) \{}
\DoxyCodeLine{                cout << \textcolor{stringliteral}{"{}MAC changed"{}};}
\DoxyCodeLine{           \}}
\DoxyCodeLine{     \};}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{          NxSdk    *sdk;}
\DoxyCodeLine{          NxMacMgr *macMgr;}
\DoxyCodeLine{          NxMac    *mac;}
\DoxyCodeLine{}
\DoxyCodeLine{          NxMacMgrHandler *mymaccb = \textcolor{keyword}{new} myMacMgrHandler();}
\DoxyCodeLine{          sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{          macMgr = sdk-\/>getMacMgr();}
\DoxyCodeLine{          macMgr-\/>setMacMgrHandler(mymaccb);}
\DoxyCodeLine{}
\DoxyCodeLine{          macMgr-\/>watchMac(2, \textcolor{stringliteral}{"{}1.1.1"{}});}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myMacMgrHandler(nx\_sdk\_py.NxMacMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{   \#\#\# Overloaded Callback to get MAC events}}
\DoxyCodeLine{         def postMacCb(self, nxmac):}
\DoxyCodeLine{             print "{}MAC has changed"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       macMgr = sdk.getMacMgr()}
\DoxyCodeLine{       mymaccb = myMacMgrHandler()}
\DoxyCodeLine{       macMgr.\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a06f53bd41ddb17e6cfaef5a02b00415d}{setMacMgrHandler}}(mymaccb)}
\DoxyCodeLine{}
\DoxyCodeLine{       macMgr.\mbox{\hyperlink{classnxos_1_1_nx_mac_mgr_a12dde38c22d9a27e1e3bde318d418134}{watchMac}}(2, "{}1.1.1"{})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em E\+R\+R\+\_\+\+I\+N\+V\+A\+L\+ID} & mac\+Addr or vlan is invalid. \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{nx__mac__mgr_8h}{nx\+\_\+mac\+\_\+mgr.\+h}}\end{DoxyCompactItemize}
