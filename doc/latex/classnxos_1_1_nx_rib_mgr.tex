\hypertarget{classnxos_1_1_nx_rib_mgr}{}\doxysection{nxos\+::Nx\+Rib\+Mgr Class Reference}
\label{classnxos_1_1_nx_rib_mgr}\index{nxos::NxRibMgr@{nxos::NxRibMgr}}


Abstract Rib Manager interface to gain access to N\+X\+OS R\+IB.  




{\ttfamily \#include $<$nx\+\_\+rib\+\_\+mgr.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a5f390bcc244b9f5984d35290aea0e2cc}{$\sim$\+Nx\+Rib\+Mgr}} ()
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_vrf}{Nx\+Vrf}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a605323f1d764bc8c27fe770a9a6b4628}{get\+Vrf}} (std\+::string vrf\+Name=\char`\"{}default\char`\"{}, bool watch=false)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a35e2a52be337d47cd111803f64aca904}{watch\+Vrf}} (std\+::string vrf\+Name=\char`\"{}all\char`\"{})=0
\item 
virtual void \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a957da78022cd4af95ee27941d0b67ce0}{unwatch\+Vrf}} (std\+::string vrf\+Name=\char`\"{}all\char`\"{})=0
\item 
virtual void \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}{set\+Rib\+Mgr\+Handler}} (\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_handler}{Nx\+Rib\+Mgr\+Handler}} $\ast$handler)=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_handler}{Nx\+Rib\+Mgr\+Handler}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_aeed917ba912782303662c4009f3fcfcd}{get\+Rib\+Mgr\+Handler}} ()=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ae84cf1b9546fc3bf70e12bc7209ca190}{get\+L3\+Route}} (std\+::string route\+Addr, unsigned char mask\+Len=0, std\+::string vrf\+Name=\char`\"{}default\char`\"{}, bool clear\+Buffer=false)=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ab6749ea02f53fc8b2f6cdba21bbc335d}{watch\+L3\+Route}} (std\+::string protocol, std\+::string tag=\char`\"{}\char`\"{}, std\+::string vrf\+Name=\char`\"{}all\char`\"{}, nxos\+::af\+\_\+e af=\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119}{nxos\+::\+M\+A\+X\+\_\+\+AF}})=0
\item 
virtual void \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a1dc61ed1d830f50ea947707576d75b99}{unwatch\+L3\+Route}} (std\+::string protocol, std\+::string tag=\char`\"{}\char`\"{}, std\+::string vrf\+Name=\char`\"{}all\char`\"{}, nxos\+::af\+\_\+e af=\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119}{nxos\+::\+M\+A\+X\+\_\+\+AF}})=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a7bf169a5f8d7b30090c4b3c67468ac18}{get\+L3\+Route\+Detail}} (const std\+::string \&route\+Addr, unsigned int mask\+Len=0, const std\+::string \&vrf\+Name=\char`\"{}default\char`\"{})=0
\item 
virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} $\ast$ \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a59da8782bb5d41a130c8c238abc92bc3}{add\+L3\+Route}} (const std\+::string \&route\+Addr, unsigned char mask\+Len=0, const std\+::string \&vrf\+Name=\char`\"{}default\char`\"{})=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a6d838df92cbcc60bf81dabc31b2dd5b1}{del\+L3\+Route}} (const std\+::string \&route\+Prefix, unsigned char mask\+Len=0, const std\+::string \&vrf\+Name=\char`\"{}default\char`\"{})=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a0eb60de76f9a6b028350b8144a590e19}{send\+My\+L3\+Routes\+To\+Rib}} (\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}} af=\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{nxos\+::\+A\+F\+\_\+\+I\+P\+V4}})=0
\item 
virtual bool \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a7edd313ab7852713469d84ac588cd08d}{converged}} (\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}} af=\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{nxos\+::\+A\+F\+\_\+\+I\+P\+V4}}, const std\+::string \&vrf\+Name=\char`\"{}all\char`\"{})=0
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Abstract Rib Manager interface to gain access to N\+X\+OS R\+IB. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a5f390bcc244b9f5984d35290aea0e2cc}\label{classnxos_1_1_nx_rib_mgr_a5f390bcc244b9f5984d35290aea0e2cc}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!````~NxRibMgr@{$\sim$NxRibMgr}}
\index{````~NxRibMgr@{$\sim$NxRibMgr}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{$\sim$NxRibMgr()}{~NxRibMgr()}}
{\footnotesize\ttfamily virtual nxos\+::\+Nx\+Rib\+Mgr\+::$\sim$\+Nx\+Rib\+Mgr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Destructor

To Delete the R\+IB manager instance and its associated objects gracefully. Its cleaned on delete sdk too. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a59da8782bb5d41a130c8c238abc92bc3}\label{classnxos_1_1_nx_rib_mgr_a59da8782bb5d41a130c8c238abc92bc3}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!addL3Route@{addL3Route}}
\index{addL3Route@{addL3Route}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{addL3Route()}{addL3Route()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}}$\ast$ nxos\+::\+Nx\+Rib\+Mgr\+::add\+L3\+Route (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{route\+Addr,  }\item[{unsigned char}]{mask\+Len = {\ttfamily 0},  }\item[{const std\+::string \&}]{vrf\+Name = {\ttfamily \char`\"{}default\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To add a L3 Route object. This A\+PI will return a route object to add/update/remove next-\/hops. All operations take place when send\+My\+L3\+Routes\+To\+Rib is called. post\+My\+L3\+Route\+Cb is called after send\+My\+L3\+Routes\+To\+Rib is called to signal that route changes are done. post\+L3\+Recursive\+Next\+Hop\+Cb is called after send\+My\+L3\+Routes\+To\+Rib to signal changes to the next hop. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em route\+Addr} & Address of the route as a string. \\
\hline
\mbox{\texttt{ in}}  & {\em mask\+Len} & \mbox{[}Optional\mbox{]} Mask\+Length if its a prefix. If not set it will pick /32 for IP address (or) /128 for I\+Pv6 address. \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Vrf\+Name in which the route is present. If not set \char`\"{}default\char`\"{} will be used. vrf\+Name cannot be \char`\"{}all\char`\"{} or empty string \char`\"{}\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} object to be used to further configure the route. N\+U\+LL if not (Vrf\+Name empty (or) \char`\"{}all\char`\"{}, Vrf does not exist, down or invalid, no route etc).
\end{DoxyReturn}
Write A\+PI -\/ N\+X-\/\+S\+DK Applications can use this A\+PI only if security profile with permit (or) throttle is enabled for that application. Using this A\+PI without the appropriate security profiles will throw an exception. Refer to readmes/security\+\_\+profiles.\+md for more info in N\+X-\/\+S\+DK Git repo.


\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxL3Route    *route;}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr-\/>addL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{     NxL3NextHop *nh = route-\/>addL3DirectNextHop(\textcolor{stringliteral}{"{}10.1.1.3"{}}, }
\DoxyCodeLine{                                                 \textcolor{stringliteral}{"{}Eth1/3"{}} 12);}
\DoxyCodeLine{     \textcolor{keywordtype}{bool} result = route-\/>sendMyL3RoutesToRib(\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{AF\_IPV4}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr.addL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}})}
\DoxyCodeLine{     next\_hop = route.addL3DirectNextHop(\textcolor{stringliteral}{"{}10.1.1.3"{}}, \textcolor{stringliteral}{"{}Eth1/3"{}}, 12)}
\DoxyCodeLine{     result = ribMgr.sendMyL3RoutesToRib(nx\_sdk\_py.AF\_IPV4)}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em invalid} & route\+Addr \\
\hline
{\em invalid} & mask\+Len \\
\hline
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a7edd313ab7852713469d84ac588cd08d}\label{classnxos_1_1_nx_rib_mgr_a7edd313ab7852713469d84ac588cd08d}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!converged@{converged}}
\index{converged@{converged}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{converged()}{converged()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Rib\+Mgr\+::converged (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}}}]{af = {\ttfamily \mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{nxos\+::\+A\+F\+\_\+\+I\+P\+V4}}},  }\item[{const std\+::string \&}]{vrf\+Name = {\ttfamily \char`\"{}all\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Tell Route information base that all routes belonging to the application were programmed. This is needed after system switch over and the application has added all its routes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em af} & Address Family \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & Name of the V\+RF\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if send\+My\+L3\+Routes\+To\+Rib operation succeeded.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{keywordtype}{bool} result = ribMgr-\/>converged();}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     result = ribMgr.converged()}
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a6d838df92cbcc60bf81dabc31b2dd5b1}\label{classnxos_1_1_nx_rib_mgr_a6d838df92cbcc60bf81dabc31b2dd5b1}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!delL3Route@{delL3Route}}
\index{delL3Route@{delL3Route}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{delL3Route()}{delL3Route()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Rib\+Mgr\+::del\+L3\+Route (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{route\+Prefix,  }\item[{unsigned char}]{mask\+Len = {\ttfamily 0},  }\item[{const std\+::string \&}]{vrf\+Name = {\ttfamily \char`\"{}default\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To delete a L3 Route and all it\textquotesingle{}s next-\/hops owned by the application.

post\+My\+L3\+Route\+Cb is called after send\+My\+L3\+Routes\+To\+Rib is called to signal that route changes are done.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em route\+Addr} & Address of the route as a string. \\
\hline
\mbox{\texttt{ in}}  & {\em mask\+Len} & \mbox{[}Optional\mbox{]} Mask\+Length if its a prefix. If not set it will pick /32 for IP address (or) /128 for I\+Pv6 address. \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Vrf\+Name in which the route is present. If not set \char`\"{}default\char`\"{} will be used. vrf\+Name cannot be \char`\"{}all\char`\"{} or empty string \char`\"{}\char`\"{}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false
\end{DoxyReturn}
Write A\+PI -\/ N\+X-\/\+S\+DK Applications can use this A\+PI only if security profile with permit (or) throttle is enabled for that application. Using this A\+PI without the appropriate security profiles will throw an exception. Refer to readmes/security\+\_\+profiles.\+md for more info in N\+X-\/\+S\+DK Git repo. 
\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxL3Route    *route;}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr-\/>getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr.getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em invalid} & route\+Addr \\
\hline
{\em invalid} & mask\+Len \\
\hline
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_ae84cf1b9546fc3bf70e12bc7209ca190}\label{classnxos_1_1_nx_rib_mgr_ae84cf1b9546fc3bf70e12bc7209ca190}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!getL3Route@{getL3Route}}
\index{getL3Route@{getL3Route}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{getL3Route()}{getL3Route()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}}$\ast$ nxos\+::\+Nx\+Rib\+Mgr\+::get\+L3\+Route (\begin{DoxyParamCaption}\item[{std\+::string}]{route\+Addr,  }\item[{unsigned char}]{mask\+Len = {\ttfamily 0},  }\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}default\char`\"{}},  }\item[{bool}]{clear\+Buffer = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the L3 Route with it\textquotesingle{}s bext next-\/hop based on the passed input parameters. Routes returned by this function cannot be used to add\+L3\+Direct\+Next\+Hop() or add\+L3\+Recursive\+Next\+Hop() 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em route\+Addr} & Address of the route as a string. \\
\hline
\mbox{\texttt{ in}}  & {\em mask\+Len} & \mbox{[}Optional\mbox{]} Mask\+Length if its a prefix. If not set it will pick /32 for IP address (or) /128 for I\+Pv6 address. \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Vrf\+Name in which the route is present. If not set \char`\"{}default\char`\"{} will be used. vrf\+Name cannot be \char`\"{}all\char`\"{} or empty string \char`\"{}\char`\"{}. \\
\hline
\mbox{\texttt{ in}}  & {\em clear\+Buffer} & \mbox{[}Optional\mbox{]} If the route is present, \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ae84cf1b9546fc3bf70e12bc7209ca190}{get\+L3\+Route()}} creates a new \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} object. \mbox{[}Recommended\mbox{]} App owners must free/destory the L3 Route object once done. If they fail to free it, N\+X\+S\+DK will store the object until its freed. N\+O\+TE\+: N\+X\+S\+DK allows a max of 10 get\+L3\+Route Objects per V\+RF without having the Apps to free it explicitly. If user failed to cleanup after 10 get\+L3\+Route objects, it will raise an exception. If the App owners, failed/forgot to free the route object then set clear\+Buffer flag to True which will free all the previously created route objects. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} object if it exists. N\+U\+LL if not (Vrf\+Name empty (or) \char`\"{}all\char`\"{}, Vrf does not exist, down or invalid, no route etc).
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxL3Route    *route;}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr-\/>getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr.getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em invalid} & route\+Addr \\
\hline
{\em invalid} & mask\+Len \\
\hline
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a7bf169a5f8d7b30090c4b3c67468ac18}\label{classnxos_1_1_nx_rib_mgr_a7bf169a5f8d7b30090c4b3c67468ac18}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!getL3RouteDetail@{getL3RouteDetail}}
\index{getL3RouteDetail@{getL3RouteDetail}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{getL3RouteDetail()}{getL3RouteDetail()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}}$\ast$ nxos\+::\+Nx\+Rib\+Mgr\+::get\+L3\+Route\+Detail (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{route\+Addr,  }\item[{unsigned int}]{mask\+Len = {\ttfamily 0},  }\item[{const std\+::string \&}]{vrf\+Name = {\ttfamily \char`\"{}default\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the L3 Route with all its next-\/hops based on the passed input parameters. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em route\+Addr} & Address of the route as a string. \\
\hline
\mbox{\texttt{ in}}  & {\em mask\+Len} & \mbox{[}Optional\mbox{]} Mask\+Length if its a prefix. If not set it will pick /32 for IP address (or) /128 for I\+Pv6 address. \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Vrf\+Name in which the route is present. If not set \char`\"{}default\char`\"{} will be used. vrf\+Name cannot be \char`\"{}all\char`\"{} or empty string \char`\"{}\char`\"{}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classnxos_1_1_nx_l3_route}{Nx\+L3\+Route}} object if it exists. N\+U\+LL if not (Vrf\+Name empty (or) \char`\"{}all\char`\"{}, Vrf does not exist, down or invalid, no route etc).
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxL3Route    *route;}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr-\/>getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr.getL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em invalid} & route\+Addr \\
\hline
{\em invalid} & mask\+Len \\
\hline
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_aeed917ba912782303662c4009f3fcfcd}\label{classnxos_1_1_nx_rib_mgr_aeed917ba912782303662c4009f3fcfcd}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!getRibMgrHandler@{getRibMgrHandler}}
\index{getRibMgrHandler@{getRibMgrHandler}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{getRibMgrHandler()}{getRibMgrHandler()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_handler}{Nx\+Rib\+Mgr\+Handler}}$\ast$ nxos\+::\+Nx\+Rib\+Mgr\+::get\+Rib\+Mgr\+Handler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the Handler object registered with R\+IB Mgr. \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a605323f1d764bc8c27fe770a9a6b4628}\label{classnxos_1_1_nx_rib_mgr_a605323f1d764bc8c27fe770a9a6b4628}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!getVrf@{getVrf}}
\index{getVrf@{getVrf}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{getVrf()}{getVrf()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classnxos_1_1_nx_vrf}{Nx\+Vrf}}$\ast$ nxos\+::\+Nx\+Rib\+Mgr\+::get\+Vrf (\begin{DoxyParamCaption}\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}default\char`\"{}},  }\item[{bool}]{watch = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To get the V\+RF object from a given name. Returns N\+U\+LL if \char`\"{}all\char`\"{} (or) empty string \char`\"{}\char`\"{} is passed. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vrf\+Name} & name of the V\+RF in string. vrf\+Name cannot be \char`\"{}all\char`\"{} or empty string \char`\"{}\char`\"{} \\
\hline
\mbox{\texttt{ in}}  & {\em watch} & \mbox{[}Optional\mbox{]} set to True if this V\+RF needs to be tracked. By default, its set to False. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classnxos_1_1_nx_vrf}{Nx\+Vrf}} Object if it exists. N\+U\+LL if it does not exist.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxVrf *vrf;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     vrf = ribMgr-\/>getVrf(\textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     vrf = ribMgr.getVrf(\textcolor{stringliteral}{"{}default"{}})}
\end{DoxyCode}
 
\begin{DoxyExceptions}{Exceptions}
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a0eb60de76f9a6b028350b8144a590e19}\label{classnxos_1_1_nx_rib_mgr_a0eb60de76f9a6b028350b8144a590e19}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!sendMyL3RoutesToRib@{sendMyL3RoutesToRib}}
\index{sendMyL3RoutesToRib@{sendMyL3RoutesToRib}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{sendMyL3RoutesToRib()}{sendMyL3RoutesToRib()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Rib\+Mgr\+::send\+My\+L3\+Routes\+To\+Rib (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}}}]{af = {\ttfamily \mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{nxos\+::\+A\+F\+\_\+\+I\+P\+V4}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Send all pending route operations to R\+IB. This call is asynchronous. To check if route was added properly, override post\+My\+L3\+Route\+Cb to be notified when your route is added or deleted.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em af} & \mbox{[}Optional\mbox{]} Register for route events only from the specified address-\/family (af). For ex) To get only I\+Pv4 route events, use A\+F\+\_\+\+I\+P\+V4 etc. IF not speficied, it means from all A\+Fs.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if send\+My\+L3\+Routes\+To\+Rib operation succeeded.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxL3Route    *route;}
\DoxyCodeLine{}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr-\/>addL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}});}
\DoxyCodeLine{     NxL3NextHop *nh = route-\/>addL3DirectNextHop(\textcolor{stringliteral}{"{}10.1.1.3"{}}, }
\DoxyCodeLine{                                                 \textcolor{stringliteral}{"{}Eth1/3"{}}, 12);}
\DoxyCodeLine{     \textcolor{keywordtype}{bool} result = route-\/>sendMyL3RoutesToRib(\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{AF\_IPV4}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     route = ribMgr.addL3Route(\textcolor{stringliteral}{"{}10.1.1.1"{}}, 24, \textcolor{stringliteral}{"{}default"{}})}
\DoxyCodeLine{     next\_hop = route.addL3DirectNextHop(\textcolor{stringliteral}{"{}10.1.1.3"{}}, \textcolor{stringliteral}{"{}Eth1/3"{}}, 12)}
\DoxyCodeLine{     result = ribMgr.sendMyL3RoutesToRib(nx\_sdk\_py.AF\_IPV4)}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em invalid} & Address family \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}\label{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!setRibMgrHandler@{setRibMgrHandler}}
\index{setRibMgrHandler@{setRibMgrHandler}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{setRibMgrHandler()}{setRibMgrHandler()}}
{\footnotesize\ttfamily virtual void nxos\+::\+Nx\+Rib\+Mgr\+::set\+Rib\+Mgr\+Handler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_handler}{Nx\+Rib\+Mgr\+Handler}} $\ast$}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Users to overload R\+IB Manager Handler class to handle regsiterd events like V\+RF, Route updates etc and register the handler object with R\+IB manager to handle rib events. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_handler}{Nx\+Rib\+Mgr\+Handler}}} & object with user overloaded functions to handle rib events.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myRibMgrMgrHandler : \textcolor{keyword}{public} NxRibMgrHandler \{}
\DoxyCodeLine{      \textcolor{keyword}{public}:}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} postL3RouteCb(NxL3Route *route) \{}
\DoxyCodeLine{              \textcolor{comment}{// Do your action}}
\DoxyCodeLine{         \}}
\DoxyCodeLine{   \};}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{        NxSdk    *sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{        NxRibMgr *ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{        NxRibMgrHandler *myribcb = \textcolor{keyword}{new} myRibMgrHandler();}
\DoxyCodeLine{        ribMgr-\/>setRibMgrHandler(myribcb);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myRibMgrHandler(nx\_sdk\_py.NxRibMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{   \#\#\# Overloaded Callback to get Route events}}
\DoxyCodeLine{         def postL3RouteCb(self, nxroute):}
\DoxyCodeLine{\textcolor{preprocessor}{             \# Do your action here}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{       myribcb = myRibMgrHandler()}
\DoxyCodeLine{       ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}{setRibMgrHandler}}(myribcb)}
\end{DoxyCode}
 \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a1dc61ed1d830f50ea947707576d75b99}\label{classnxos_1_1_nx_rib_mgr_a1dc61ed1d830f50ea947707576d75b99}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!unwatchL3Route@{unwatchL3Route}}
\index{unwatchL3Route@{unwatchL3Route}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{unwatchL3Route()}{unwatchL3Route()}}
{\footnotesize\ttfamily virtual void nxos\+::\+Nx\+Rib\+Mgr\+::unwatch\+L3\+Route (\begin{DoxyParamCaption}\item[{std\+::string}]{protocol,  }\item[{std\+::string}]{tag = {\ttfamily \char`\"{}\char`\"{}},  }\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}all\char`\"{}},  }\item[{\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}}}]{af = {\ttfamily \mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119}{nxos\+::\+M\+A\+X\+\_\+\+AF}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To unsubscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em protocol} & Owner of the routes in NX R\+IB. \\
\hline
\mbox{\texttt{ in}}  & {\em tag} & \mbox{[}Optional\mbox{]} instance id of the owner for ex) for B\+GP -\/ tag is the asn for isis -\/ instance id \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrf\+Name cannot be empty string. \\
\hline
\mbox{\texttt{ in}}  & {\em af} & \mbox{[}Optional\mbox{]} Register for route events only from the specified address-\/family (af). For ex) To get only I\+Pv4 route events, use A\+F\+\_\+\+I\+P\+V4 etc. IF not speficied, it means from all A\+Fs.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{        NxSdk    *sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{        NxRibMgr *ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{        ribMgr-\/>unwatchL3Route(\textcolor{stringliteral}{"{}bgp"{}}, \textcolor{stringliteral}{"{}100"{}}, \textcolor{stringliteral}{"{}vpn1"{}});}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{       ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a1dc61ed1d830f50ea947707576d75b99}{unwatchL3Route}}(\textcolor{stringliteral}{"{}bgp"{}}, \textcolor{stringliteral}{"{}100"{}}, \textcolor{stringliteral}{"{}vpn1"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em vrf\+Name} & is more than 32 characters.\\
\hline
\end{DoxyExceptions}
N\+O\+TE\+: Use the pregenerated \char`\"{}show $<$appname$>$ nxsdk rib\+Mgr\char`\"{} command to verify if the A\+PI has succeeded. \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a957da78022cd4af95ee27941d0b67ce0}\label{classnxos_1_1_nx_rib_mgr_a957da78022cd4af95ee27941d0b67ce0}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!unwatchVrf@{unwatchVrf}}
\index{unwatchVrf@{unwatchVrf}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{unwatchVrf()}{unwatchVrf()}}
{\footnotesize\ttfamily virtual void nxos\+::\+Nx\+Rib\+Mgr\+::unwatch\+Vrf (\begin{DoxyParamCaption}\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}all\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To unsubscribe for any updates to this V\+RF. To unsubscribe for all V\+RF updates, use vrf\+Name as \char`\"{}all\char`\"{}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Vrf\+Name} & \mbox{[}Optional\mbox{]} name of the vrf in string. If not specified, \char`\"{}all\char`\"{} is used to unwatch all V\+R\+Fs. Vrf\+Name cannot be empty string.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{     \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{     NxVrf *vrf;}
\DoxyCodeLine{     sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{     ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{}
\DoxyCodeLine{     ribMgr-\/>unwatchVrf(\textcolor{stringliteral}{"{}vpn1"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{     \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{     sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{     ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{}
\DoxyCodeLine{     ribMgr.unwatchVrf(\textcolor{stringliteral}{"{}vpn1"{}})}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em vrf\+Name} & is more than 32 characters.\\
\hline
\end{DoxyExceptions}
N\+O\+TE\+: Use the pregenerated \char`\"{}show $<$appname$>$ nxsdk rib\+Mgr\char`\"{} command to verify if the A\+PI has succeeded. \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_ab6749ea02f53fc8b2f6cdba21bbc335d}\label{classnxos_1_1_nx_rib_mgr_ab6749ea02f53fc8b2f6cdba21bbc335d}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!watchL3Route@{watchL3Route}}
\index{watchL3Route@{watchL3Route}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{watchL3Route()}{watchL3Route()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Rib\+Mgr\+::watch\+L3\+Route (\begin{DoxyParamCaption}\item[{std\+::string}]{protocol,  }\item[{std\+::string}]{tag = {\ttfamily \char`\"{}\char`\"{}},  }\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}all\char`\"{}},  }\item[{\mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7}{nxos\+::af\+\_\+e}}}]{af = {\ttfamily \mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119}{nxos\+::\+M\+A\+X\+\_\+\+AF}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To receive/subscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded post\+L3\+Route\+Cb handler will be called. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em protocol} & owner of the routes in NX R\+IB. \\
\hline
\mbox{\texttt{ in}}  & {\em tag} & \mbox{[}Optional\mbox{]} instance id of the owner for ex) for B\+GP -\/ tag is the asn for isis -\/ instance id \\
\hline
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrf\+Name cannot be empty string. \\
\hline
\mbox{\texttt{ in}}  & {\em af} & \mbox{[}Optional\mbox{]} Register for route events only from the specified address-\/family (af). For ex) To get only I\+Pv4 route events, use A\+F\+\_\+\+I\+P\+V4 etc. IF not speficied, it means from all A\+Fs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful(\+Empty V\+Rf\+Name).
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{C++:}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{   \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myRibMgrMgrHandler : \textcolor{keyword}{public} NxRibMgrHandler \{}
\DoxyCodeLine{      \textcolor{keyword}{public}:}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} postL3RouteCb(NxL3Route *route) \{}
\DoxyCodeLine{              cout << \textcolor{stringliteral}{"{}Received bgp-\/100 updates for IPV4 routes on vpn1"{}};}
\DoxyCodeLine{         \}}
\DoxyCodeLine{   \};}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{        NxSdk    *sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{        NxRibMgr *ribMgr;}
\DoxyCodeLine{        NxRibMgrHandler *myribcb = \textcolor{keyword}{new} myRibMgrMgrHandler();}
\DoxyCodeLine{}
\DoxyCodeLine{        ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (ribMgr) \{}
\DoxyCodeLine{            ribMgr-\/>setRibMgrHandler(myribcb);}
\DoxyCodeLine{            ribMgr-\/>watchL3Route(\textcolor{stringliteral}{"{}bgp"{}}, \textcolor{stringliteral}{"{}100"{}}, \textcolor{stringliteral}{"{}vpn1"{}}, \mbox{\hyperlink{namespacenxos_a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628}{nxos::AF\_IPV4}});}
\DoxyCodeLine{        \}}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{Python:}
\DoxyCodeLine{   \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keyword}{class }myRibMgrHandler(nx\_sdk\_py.NxRibMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{   \#\#\# Overloaded Callback to get Route events}}
\DoxyCodeLine{         def postL3RouteCb(self, nxroute):}
\DoxyCodeLine{             print "{}Received bgp-\/100 updates for IPV4 routes on vpn1"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{   \# Do SDK related inits in one thread.}}
\DoxyCodeLine{   def sdkThread(name,val):}
\DoxyCodeLine{       sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{       myribcb = myRibMgrHandler()}
\DoxyCodeLine{       if sdk:}
\DoxyCodeLine{          ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{          if ribMgr:}
\DoxyCodeLine{             ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}{setRibMgrHandler}}(myribcb)}
\DoxyCodeLine{             ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ab6749ea02f53fc8b2f6cdba21bbc335d}{watchL3Route}}("{}bgp"{}, "{}100"{}, "{}vpn1"{}, nxos::AF\_IPV4)}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em vrf\+Name} & is more than 32 characters. \\
\hline
{\em reached} & maximum watch filter count\+: 15 for this Address-\/\+Family(AF) in this V\+RF.\\
\hline
\end{DoxyExceptions}
N\+O\+TE\+: Use the pregenerated \char`\"{}show $<$appname$>$ nxsdk rib\+Mgr\char`\"{} command to verify if the A\+PI has succeeded. \mbox{\Hypertarget{classnxos_1_1_nx_rib_mgr_a35e2a52be337d47cd111803f64aca904}\label{classnxos_1_1_nx_rib_mgr_a35e2a52be337d47cd111803f64aca904}} 
\index{nxos::NxRibMgr@{nxos::NxRibMgr}!watchVrf@{watchVrf}}
\index{watchVrf@{watchVrf}!nxos::NxRibMgr@{nxos::NxRibMgr}}
\doxysubsubsection{\texorpdfstring{watchVrf()}{watchVrf()}}
{\footnotesize\ttfamily virtual bool nxos\+::\+Nx\+Rib\+Mgr\+::watch\+Vrf (\begin{DoxyParamCaption}\item[{std\+::string}]{vrf\+Name = {\ttfamily \char`\"{}all\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

To receive/subscribe for any updates to this V\+RF. On any update to this V\+RF, users overloaded post\+Vrf\+Cb handler will be called. To subscribe for all V\+R\+Fs, use vrf\+Name as \char`\"{}all\char`\"{}. N\+O\+TE\+: Forward referencing is allowed for a non created V\+RF i.\+e A\+PI can be called even if the V\+RF is not yet created. vrf\+Name cannot be empty. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vrf\+Name} & \mbox{[}Optional\mbox{]} name of the vrf in string. If not specified, \char`\"{}all\char`\"{} is used to watch on all V\+R\+Fs. Vrf\+Name cannot be empty string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True -\/ if successful. False -\/ if not successful(\+Empty V\+Rf\+Name).
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{ C++:}
\DoxyCodeLine{\textcolor{preprocessor}{      \#include <\mbox{\hyperlink{nx__sdk_8h}{nx\_sdk.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{      \#include <\mbox{\hyperlink{nx__rib__mgr_8h}{nx\_rib\_mgr.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{keyword}{class }myRibMgrMgrHandler : \textcolor{keyword}{public} NxRibMgrHandler \{}
\DoxyCodeLine{         \textcolor{keyword}{public}:}
\DoxyCodeLine{            \textcolor{keywordtype}{bool} postVrfCb(NxVrf *vrf) \{}
\DoxyCodeLine{                 cout << \textcolor{stringliteral}{"{}Vpn1 VRF changed"{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{      \};}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{keywordtype}{int}  main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{           NxSdk    *sdk;}
\DoxyCodeLine{           NxRibMgr *ribMgr;}
\DoxyCodeLine{           NxVrf    *vrf;}
\DoxyCodeLine{}
\DoxyCodeLine{           NxRibMgrHandler *myribcb = \textcolor{keyword}{new} myRibMgrHandler();}
\DoxyCodeLine{           sdk = \mbox{\hyperlink{classnxos_1_1_nx_sdk_a5050e2d26c40744b4fc7862068a83f39}{nxos::NxSdk::getSdkInst}}(argc, argv);}
\DoxyCodeLine{           ribMgr = sdk-\/>getRibMgr();}
\DoxyCodeLine{           ribMgr-\/>setRibMgrHandler(myribcb);}
\DoxyCodeLine{}
\DoxyCodeLine{           ribMgr-\/>watchVrf(\textcolor{stringliteral}{"{}vpn1"{}});}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{ Python:}
\DoxyCodeLine{    \textcolor{keyword}{import} nx\_sdk\_py}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{class }myRibMgrHandler(nx\_sdk\_py.NxRibMgrHandler):}
\DoxyCodeLine{\textcolor{preprocessor}{    \#\#\# Overloaded Callback to get Route events}}
\DoxyCodeLine{          def postVrfCb(self, nxvrf):}
\DoxyCodeLine{              print "{}vpn1 has changed"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{    \# Do SDK related inits in one thread.}}
\DoxyCodeLine{    def sdkThread(name,val):}
\DoxyCodeLine{        sdk = nx\_sdk\_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)}
\DoxyCodeLine{        ribMgr = sdk.getRibMgr()}
\DoxyCodeLine{        myribcb = myRibMgrHandler()}
\DoxyCodeLine{        ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_ac42dd29e34f9c508614733dbec518b99}{setRibMgrHandler}}(myribcb)}
\DoxyCodeLine{}
\DoxyCodeLine{        ribMgr.\mbox{\hyperlink{classnxos_1_1_nx_rib_mgr_a35e2a52be337d47cd111803f64aca904}{watchVrf}}("{}vpn1"{})}
\DoxyCodeLine{NOTE: Use the pregenerated "{}show <appname> nxsdk ribMgr"{} command}
\DoxyCodeLine{      to verify if the API has succeeded.}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em vrf\+Name} & is more than 32 characters. \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{nx__rib__mgr_8h}{nx\+\_\+rib\+\_\+mgr.\+h}}\end{DoxyCompactItemize}
