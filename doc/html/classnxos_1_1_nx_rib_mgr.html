<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NX-SDK API: nxos::NxRibMgr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NX-SDK API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classnxos_1_1_nx_rib_mgr.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnxos_1_1_nx_rib_mgr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nxos::NxRibMgr Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract Rib Manager interface to gain access to NXOS RIB.  
 <a href="classnxos_1_1_nx_rib_mgr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nx__rib__mgr_8h_source.html">nx_rib_mgr.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f390bcc244b9f5984d35290aea0e2cc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#a5f390bcc244b9f5984d35290aea0e2cc">~NxRibMgr</a> ()</td></tr>
<tr class="separator:a5f390bcc244b9f5984d35290aea0e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605323f1d764bc8c27fe770a9a6b4628"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1_nx_vrf.html">NxVrf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#a605323f1d764bc8c27fe770a9a6b4628">getVrf</a> (std::string vrfName=&quot;default&quot;, bool watch=false)=0</td></tr>
<tr class="separator:a605323f1d764bc8c27fe770a9a6b4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e2a52be337d47cd111803f64aca904"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#a35e2a52be337d47cd111803f64aca904">watchVrf</a> (std::string vrfName=&quot;all&quot;)=0</td></tr>
<tr class="separator:a35e2a52be337d47cd111803f64aca904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957da78022cd4af95ee27941d0b67ce0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#a957da78022cd4af95ee27941d0b67ce0">unwatchVrf</a> (std::string vrfName=&quot;all&quot;)=0</td></tr>
<tr class="separator:a957da78022cd4af95ee27941d0b67ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42dd29e34f9c508614733dbec518b99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a> (<a class="el" href="classnxos_1_1_nx_rib_mgr_handler.html">NxRibMgrHandler</a> *handler)=0</td></tr>
<tr class="separator:ac42dd29e34f9c508614733dbec518b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed917ba912782303662c4009f3fcfcd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1_nx_rib_mgr_handler.html">NxRibMgrHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#aeed917ba912782303662c4009f3fcfcd">getRibMgrHandler</a> ()=0</td></tr>
<tr class="separator:aeed917ba912782303662c4009f3fcfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84cf1b9546fc3bf70e12bc7209ca190"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1_nx_l3_route.html">NxL3Route</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#ae84cf1b9546fc3bf70e12bc7209ca190">getL3Route</a> (std::string routeAddr, unsigned char maskLen=0, std::string vrfName=&quot;default&quot;, bool clearBuffer=false)=0</td></tr>
<tr class="separator:ae84cf1b9546fc3bf70e12bc7209ca190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6749ea02f53fc8b2f6cdba21bbc335d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#ab6749ea02f53fc8b2f6cdba21bbc335d">watchL3Route</a> (std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=<a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119">nxos::MAX_AF</a>)=0</td></tr>
<tr class="separator:ab6749ea02f53fc8b2f6cdba21bbc335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc61ed1d830f50ea947707576d75b99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1_nx_rib_mgr.html#a1dc61ed1d830f50ea947707576d75b99">unwatchL3Route</a> (std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=<a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119">nxos::MAX_AF</a>)=0</td></tr>
<tr class="separator:a1dc61ed1d830f50ea947707576d75b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract Rib Manager interface to gain access to NXOS RIB. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f390bcc244b9f5984d35290aea0e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f390bcc244b9f5984d35290aea0e2cc">&#9670;&nbsp;</a></span>~NxRibMgr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nxos::NxRibMgr::~NxRibMgr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>To Delete the RIB manager instance and its associated objects gracefully. Its cleaned on delete sdk too. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae84cf1b9546fc3bf70e12bc7209ca190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84cf1b9546fc3bf70e12bc7209ca190">&#9670;&nbsp;</a></span>getL3Route()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1_nx_l3_route.html">NxL3Route</a>* nxos::NxRibMgr::getL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>routeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maskLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;default&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To get the L3 Route based on the passed input parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">routeAddr</td><td>Address of the route as a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maskLen</td><td>[Optional] MaskLength if its a prefix. If not set it will pick /32 for IP address (or) /128 for IPv6 address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrfName</td><td>[Optional] VrfName in which the route is present. If not set "default" will be used. vrfName cannot be "all" or empty string "". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearBuffer</td><td>[Optional] If the route is present, <a class="el" href="classnxos_1_1_nx_rib_mgr.html#ae84cf1b9546fc3bf70e12bc7209ca190">getL3Route()</a> creates a new <a class="el" href="classnxos_1_1_nx_l3_route.html" title="Abstract Route Interface to Add/Delete and receive Route updates from NXOS RIB. ">NxL3Route</a> object. [Recommended] App owners must free/destory the L3 Route object once done. If they fail to free it, NXSDK will store the object until its freed. NOTE: NXSDK allows a max of 10 getL3Route Objects per VRF without having the Apps to free it explicitly. If user failed to cleanup after 10 getL3Route objects, it will raise an exception. If the App owners, failed/forgot to free the route object then set clearBuffer flag to True which will free all the previously created route objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classnxos_1_1_nx_l3_route.html" title="Abstract Route Interface to Add/Delete and receive Route updates from NXOS RIB. ">NxL3Route</a> object if it exists. NULL if not (VrfName empty (or) "all", Vrf does not exist, down or invalid, no route etc).</dd></dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">     NxL3Route    *route;</div><div class="line"></div><div class="line">     sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">     ribMgr = sdk-&gt;getRibMgr();</div><div class="line"></div><div class="line">     route = ribMgr-&gt;getL3Route(<span class="stringliteral">&quot;10.1.1.1&quot;</span>, 24, <span class="stringliteral">&quot;default&quot;</span>);</div><div class="line"></div><div class="line">Python:</div><div class="line">     <span class="keyword">import</span> nx_sdk_py</div><div class="line">     sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">     ribMgr = sdk.getRibMgr()</div><div class="line"></div><div class="line">     route = ribMgr.getL3Route(<span class="stringliteral">&quot;10.1.1.1&quot;</span>, 24, <span class="stringliteral">&quot;default&quot;</span>)</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid</td><td>routeAddr </td></tr>
    <tr><td class="paramname">invalid</td><td>maskLen </td></tr>
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters. </td></tr>
    <tr><td class="paramname">getRoute</td><td>buffer is full, cleanup previous pointers (or) call getL3Route with clearBuffer set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed917ba912782303662c4009f3fcfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed917ba912782303662c4009f3fcfcd">&#9670;&nbsp;</a></span>getRibMgrHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1_nx_rib_mgr_handler.html">NxRibMgrHandler</a>* nxos::NxRibMgr::getRibMgrHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To get the Handler object registered with RIB Mgr. </p>

</div>
</div>
<a id="a605323f1d764bc8c27fe770a9a6b4628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605323f1d764bc8c27fe770a9a6b4628">&#9670;&nbsp;</a></span>getVrf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1_nx_vrf.html">NxVrf</a>* nxos::NxRibMgr::getVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;default&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>watch</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To get the VRF object from a given name. Returns NULL if "all" (or) empty string "" is passed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrfName</td><td>name of the VRF in string. vrfName cannot be "all" or empty string "" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">watch</td><td>[Optional] set to True if this VRF needs to be tracked. By default, its set to False. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classnxos_1_1_nx_vrf.html" title="Abstract VRF Interface used to get details about a VRF. ">NxVrf</a> Object if it exists. NULL if it does not exist.</dd></dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">     NxVrf *vrf;</div><div class="line">     sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">     ribMgr = sdk-&gt;getRibMgr();</div><div class="line"></div><div class="line">     vrf = ribMgr-&gt;getVrf(<span class="stringliteral">&quot;default&quot;</span>);</div><div class="line"></div><div class="line">Python:</div><div class="line">     <span class="keyword">import</span> nx_sdk_py</div><div class="line">     sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">     ribMgr = sdk.getRibMgr()</div><div class="line"></div><div class="line">     vrf = ribMgr.getVrf(<span class="stringliteral">&quot;default&quot;</span>)</div></div><!-- fragment --> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42dd29e34f9c508614733dbec518b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42dd29e34f9c508614733dbec518b99">&#9670;&nbsp;</a></span>setRibMgrHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::setRibMgrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnxos_1_1_nx_rib_mgr_handler.html">NxRibMgrHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Users to overload RIB Manager Handler class to handle regsiterd events like VRF, Route updates etc and register the handler object with RIB manager to handle rib events. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classnxos_1_1_nx_rib_mgr_handler.html" title="Abstract RibMgr callback Interface to receive VRF, Route updates etc from NXOS RIB. ">NxRibMgrHandler</a></td><td>object with user overloaded functions to handle rib events.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">   <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">         <span class="keywordtype">bool</span> postL3RouteCb(NxL3Route *route) {</div><div class="line">              <span class="comment">// Do your action</span></div><div class="line">         }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">   {</div><div class="line">        NxSdk    *sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">        NxRibMgr *ribMgr = sdk-&gt;getRibMgr();</div><div class="line">        NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrHandler();</div><div class="line">        ribMgr-&gt;setRibMgrHandler(myribcb);</div><div class="line">   }</div><div class="line"></div><div class="line">Python:</div><div class="line">   <span class="keyword">import</span> nx_sdk_py</div><div class="line"></div><div class="line">   <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):</div><div class="line"><span class="preprocessor">   ### Overloaded Callback to get Route events</span></div><div class="line">         def postL3RouteCb(self, nxroute):</div><div class="line"><span class="preprocessor">             # Do your action here</span></div><div class="line"></div><div class="line"><span class="preprocessor">   # Do SDK related inits in one thread.</span></div><div class="line">   def sdkThread(name,val):</div><div class="line">       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">       ribMgr = sdk.getRibMgr()</div><div class="line">       myribcb = myRibMgrHandler()</div><div class="line">       ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)</div></div><!-- fragment --> 
</div>
</div>
<a id="a1dc61ed1d830f50ea947707576d75b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc61ed1d830f50ea947707576d75b99">&#9670;&nbsp;</a></span>unwatchL3Route()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::unwatchL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7">nxos::af_e</a>&#160;</td>
          <td class="paramname"><em>af</em> = <code><a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119">nxos::MAX_AF</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To unsubscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Owner of the routes in NX RIB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>[Optional] instance id of the owner for ex) for BGP - tag is the asn for isis - instance id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrfName</td><td>[Optional] Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrfName cannot be empty string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">af</td><td>[Optional] Register for route events only from the specified address-family (af). For ex) To get only IPv4 route events, use AF_IPV4 etc. IF not speficied, it means from all AFs.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">   <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">   {</div><div class="line">        NxSdk    *sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">        NxRibMgr *ribMgr = sdk-&gt;getRibMgr();</div><div class="line">        ribMgr-&gt;unwatchL3Route(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>);</div><div class="line">   }</div><div class="line"></div><div class="line">Python:</div><div class="line">   <span class="keyword">import</span> nx_sdk_py</div><div class="line"></div><div class="line"><span class="preprocessor">   # Do SDK related inits in one thread.</span></div><div class="line">   def sdkThread(name,val):</div><div class="line">       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">       ribMgr = sdk.getRibMgr()</div><div class="line">       ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#a1dc61ed1d830f50ea947707576d75b99">unwatchL3Route</a>(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>)</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a id="a957da78022cd4af95ee27941d0b67ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957da78022cd4af95ee27941d0b67ce0">&#9670;&nbsp;</a></span>unwatchVrf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::unwatchVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;all&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To unsubscribe for any updates to this VRF. To unsubscribe for all VRF updates, use vrfName as "all". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VrfName</td><td>[Optional] name of the vrf in string. If not specified, "all" is used to unwatch all VRFs. VrfName cannot be empty string.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">     NxVrf *vrf;</div><div class="line">     sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">     ribMgr = sdk-&gt;getRibMgr();</div><div class="line"></div><div class="line">     ribMgr-&gt;unwatchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>);</div><div class="line"></div><div class="line">Python:</div><div class="line">     <span class="keyword">import</span> nx_sdk_py</div><div class="line">     sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">     ribMgr = sdk.getRibMgr()</div><div class="line"></div><div class="line">     ribMgr.unwatchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>)</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a id="ab6749ea02f53fc8b2f6cdba21bbc335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6749ea02f53fc8b2f6cdba21bbc335d">&#9670;&nbsp;</a></span>watchL3Route()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nxos::NxRibMgr::watchL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7">nxos::af_e</a>&#160;</td>
          <td class="paramname"><em>af</em> = <code><a class="el" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7a18d0f422c857ebdfed79deb2b58ab119">nxos::MAX_AF</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To receive/subscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded postL3RouteCb handler will be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>owner of the routes in NX RIB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>[Optional] instance id of the owner for ex) for BGP - tag is the asn for isis - instance id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrfName</td><td>[Optional] Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrfName cannot be empty string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">af</td><td>[Optional] Register for route events only from the specified address-family (af). For ex) To get only IPv4 route events, use AF_IPV4 etc. IF not speficied, it means from all AFs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True - if successful. False - if not successful(Empty VRfName).</dd></dl>
<div class="fragment"><div class="line">C++:</div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">   #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">   <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">         <span class="keywordtype">bool</span> postL3RouteCb(NxL3Route *route) {</div><div class="line">              cout &lt;&lt; <span class="stringliteral">&quot;Received bgp-100 updates for IPV4 routes on vpn1&quot;</span>;</div><div class="line">         }</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">   {</div><div class="line">        NxSdk    *sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">        NxRibMgr *ribMgr;</div><div class="line">        NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrMgrHandler();</div><div class="line"></div><div class="line">        ribMgr = sdk-&gt;getRibMgr();</div><div class="line">        <span class="keywordflow">if</span> (ribMgr) {</div><div class="line">            ribMgr-&gt;setRibMgrHandler(myribcb);</div><div class="line">            ribMgr-&gt;watchL3Route(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>, <a class="code" href="namespacenxos.html#a3a667f48b94db10aa398940dc5bf72d7a038f37de02a2c9ee1acbc4e184583628">nxos::AF_IPV4</a>);</div><div class="line">        }</div><div class="line">   }</div><div class="line"></div><div class="line">Python:</div><div class="line">   <span class="keyword">import</span> nx_sdk_py</div><div class="line"></div><div class="line">   <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):</div><div class="line"><span class="preprocessor">   ### Overloaded Callback to get Route events</span></div><div class="line">         def postL3RouteCb(self, nxroute):</div><div class="line">             print &quot;Received bgp-100 updates for IPV4 routes on vpn1&quot;</div><div class="line"></div><div class="line"><span class="preprocessor">   # Do SDK related inits in one thread.</span></div><div class="line">   def sdkThread(name,val):</div><div class="line">       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">       myribcb = myRibMgrHandler()</div><div class="line">       if sdk:</div><div class="line">          ribMgr = sdk.getRibMgr()</div><div class="line">          if ribMgr:</div><div class="line">             ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)</div><div class="line">             ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#ab6749ea02f53fc8b2f6cdba21bbc335d">watchL3Route</a>(&quot;bgp&quot;, &quot;100&quot;, &quot;vpn1&quot;, nxos::AF_IPV4)</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters. </td></tr>
    <tr><td class="paramname">reached</td><td>maximum watch filter count: 15 for this Address-Family(AF) in this VRF.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a id="a35e2a52be337d47cd111803f64aca904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e2a52be337d47cd111803f64aca904">&#9670;&nbsp;</a></span>watchVrf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nxos::NxRibMgr::watchVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>vrfName</em> = <code>&quot;all&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To receive/subscribe for any updates to this VRF. On any update to this VRF, users overloaded postVrfCb handler will be called. To subscribe for all VRFs, use vrfName as "all". NOTE: Forward referencing is allowed for a non created VRF i.e API can be called even if the VRF is not yet created. vrfName cannot be empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrfName</td><td>[Optional] name of the vrf in string. If not specified, "all" is used to watch on all VRFs. VrfName cannot be empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True - if successful. False - if not successful(Empty VRfName).</dd></dl>
<div class="fragment"><div class="line"> C++:</div><div class="line"><span class="preprocessor">      #include &lt;<a class="code" href="nx__sdk_8h.html">nx_sdk.h</a>&gt;</span></div><div class="line"><span class="preprocessor">      #include &lt;<a class="code" href="nx__rib__mgr_8h.html">nx_rib_mgr.h</a>&gt;</span></div><div class="line"></div><div class="line">      <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {</div><div class="line">         <span class="keyword">public</span>:</div><div class="line">            <span class="keywordtype">bool</span> postVrfCb(NxVrf *vrf) {</div><div class="line">                 cout &lt;&lt; <span class="stringliteral">&quot;Vpn1 VRF changed&quot;</span>;</div><div class="line">            }</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">      {</div><div class="line">           NxSdk    *sdk;</div><div class="line">           NxRibMgr *ribMgr;</div><div class="line">           NxVrf    *vrf;</div><div class="line"></div><div class="line">           NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrHandler();</div><div class="line">           sdk = <a class="code" href="classnxos_1_1_nx_sdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);</div><div class="line">           ribMgr = sdk-&gt;getRibMgr();</div><div class="line">           ribMgr-&gt;setRibMgrHandler(myribcb);</div><div class="line"></div><div class="line">           ribMgr-&gt;watchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>);</div><div class="line">      }</div><div class="line"></div><div class="line"> Python:</div><div class="line">    <span class="keyword">import</span> nx_sdk_py</div><div class="line"></div><div class="line">    <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):</div><div class="line"><span class="preprocessor">    ### Overloaded Callback to get Route events</span></div><div class="line">          def postVrfCb(self, nxvrf):</div><div class="line">              print &quot;vpn1 has changed&quot;</div><div class="line"></div><div class="line"><span class="preprocessor">    # Do SDK related inits in one thread.</span></div><div class="line">    def sdkThread(name,val):</div><div class="line">        sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)</div><div class="line">        ribMgr = sdk.getRibMgr()</div><div class="line">        myribcb = myRibMgrHandler()</div><div class="line">        ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)</div><div class="line"></div><div class="line">        ribMgr.<a class="code" href="classnxos_1_1_nx_rib_mgr.html#a35e2a52be337d47cd111803f64aca904">watchVrf</a>(&quot;vpn1&quot;)</div><div class="line">NOTE: Use the pregenerated &quot;show &lt;appname&gt; nxsdk ribMgr&quot; command</div><div class="line">      to verify if the API has succeeded.</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">vrfName</td><td>is more than 32 characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/nxos-sdk@cisco.com/Documents/GitHub/nxsdk/include/<a class="el" href="nx__rib__mgr_8h_source.html">nx_rib_mgr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenxos.html">nxos</a></li><li class="navelem"><a class="el" href="classnxos_1_1_nx_rib_mgr.html">NxRibMgr</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
